import { NextRequest, NextResponse } from 'next/server'
import OpenAI from 'openai'
import { DataRow, AnalysisResult, DataSchema, ColumnSchema } from '@/lib/store'
import { scoreRecommendation, rankRecommendations, ScoredRecommendation, DataProfile, CorrectedColumn as ScorerCorrectedColumn } from '@/lib/utils/recommendation-scorer'
import { ChartSuggestion } from '@/lib/types/chart-suggestion'
import { detectDateWithConfidence, analyzeDataSchema } from '@/lib/utils/schema-analyzer'
import { parseJSONFromString } from '@/lib/utils/json-extractor'
import { createColumnMatcher, findColumn as matchColumn, type ColumnMatcher } from '@/lib/utils/column-name-matcher'
import { rebalanceCharts, getChartStats, validateChartLayout } from '@/lib/utils/chart-rebalancer'
import { hydrateChartConfigs } from '@/lib/utils/chart-hydrator'

// Production-ready logging utility
const isDevelopment = process.env.NODE_ENV === 'development'
const logger = {
  debug: (...args: any[]) => {
    if (isDevelopment) console.log(...args)
  },
  info: (...args: any[]) => {
    console.log(...args)
  },
  warn: (...args: any[]) => {
    console.warn(...args)
  },
  error: (...args: any[]) => {
    console.error(...args)
  }
}

// Enhanced request interface for user corrections feedback loop
interface AnalyzeRequest {
  data: DataRow[]
  schema?: DataSchema // Pre-computed schema with confidence scores
  correctedSchema?: Array<{
    name: string
    type: string
    description: string
    userCorrected: boolean
  }>
  feedback?: string // User feedback context
  fileName?: string
}

// AI Analysis Response structure from OpenAI
interface AIAnalysisResponse {
  insights: string[]
  chartConfig: any[] // Will be validated and typed properly later in the flow
  summary?: {
    dataQuality?: any
    keyFindings?: any
    recommendations?: any
    businessContext?: any
  }
  dataContext?: any
}

// Supported chart types - SINGLE SOURCE OF TRUTH
const SUPPORTED_CHART_TYPES = [
  'line', 'bar', 'pie', 'area', 'scatter', 'scorecard', 'table', 'combo',
  'waterfall', 'funnel', 'heatmap', 'gauge', 'cohort', 'bullet', 'treemap',
  'sankey', 'sparkline'
] as const
type SupportedChartType = typeof SUPPORTED_CHART_TYPES[number]

// Enhanced chart recommendation with chart-type-specific data mappings
interface ChartRecommendation {
  type: SupportedChartType
  title: string
  description: string
  dataMapping: {
    // Bar/Column charts
    category?: string           // X-axis categories
    values?: string[]           // Y-axis values (can be multiple)

    // Line/Area charts
    xAxis?: string              // Time or category axis
    yAxis?: string | string[]   // Metrics to plot

    // Pie charts
    value?: string              // Size of each slice

    // Scorecard
    metric?: string             // Main value
    comparison?: string         // Optional comparison value

    // Scatter
    size?: string               // Optional bubble size
    color?: string              // Optional grouping

    // Table
    columns?: string[]          // Columns to display

    // Common
    aggregation?: 'sum' | 'avg' | 'count' | 'min' | 'max' | 'distinct'

    // Top/Bottom X filtering and sorting
    sortBy?: string             // Column to sort by
    sortOrder?: 'asc' | 'desc'  // Sort direction (asc = bottom X, desc = top X)
    limit?: number              // Max number of items (default: 10)

    // Dual Y-axis support for combo charts
    yAxis2?: string[]           // Secondary Y-axis metrics
    yAxis1Label?: string        // Label for primary Y-axis
    yAxis2Label?: string        // Label for secondary Y-axis
    yAxis1Type?: 'bar' | 'line' | 'area'   // Chart type for primary axis
    yAxis2Type?: 'bar' | 'line' | 'area'   // Chart type for secondary axis

    // Waterfall specific
    type?: string               // Column indicating increase/decrease/total
    isTotal?: string            // Column marking total bars

    // Funnel specific
    stage?: string              // Funnel stage/step column
    // value already covered above

    // Heatmap specific
    // xAxis, yAxis already covered
    // value already covered

    // Gauge specific
    target?: string             // Target/goal value column
    min?: number | string       // Min value (static or column)
    max?: number | string       // Max value (static or column)
    thresholds?: Array<{value: number, color: string}>  // Color zones

    // Cohort specific
    cohort?: string             // Cohort identifier column (e.g., signup month)
    period?: string             // Time period column (e.g., weeks since signup)
    retention?: string          // Retention metric column

    // Bullet specific
    actual?: string             // Actual performance value
    // target already covered
    ranges?: Array<{label: string, value: number}>  // Performance ranges (poor/good/excellent)

    // Treemap specific
    // category already covered (for hierarchy)
    parent?: string             // Parent category for hierarchy
    // value already covered

    // Sankey specific
    source?: string             // Source node column
    // target already covered
    flow?: string               // Flow value column

    // Sparkline specific
    // xAxis already covered
    // yAxis already covered
  }
  confidence?: number           // AI confidence in this recommendation
  reasoning?: string            // Why this chart was recommended

  // Legacy support - will be deprecated
  dataKey?: string[]
  xAxis?: string | string[]
  yAxis?: string | string[]
}

/**
 * Migrates legacy xAxis/yAxis/dataKey format to new dataMapping format
 * @param config Chart configuration with legacy format
 * @returns dataMapping object for the chart type
 */
function migrateLegacyFormat(config: any): any {
  const dataMapping: any = {}

  // Get data from legacy fields
  const xAxis = config.xAxis
  const yAxis = config.yAxis
  const dataKey = config.dataKey ? (Array.isArray(config.dataKey) ? config.dataKey : [config.dataKey]) : []

  // Migrate based on chart type
  switch (config.type) {
    case 'bar':
      // Bar: category + values
      if (xAxis) {
        dataMapping.category = xAxis
      } else if (dataKey.length > 0) {
        dataMapping.category = dataKey[0]
      }

      if (yAxis) {
        dataMapping.values = Array.isArray(yAxis) ? yAxis : [yAxis]
      } else if (dataKey.length > 1) {
        dataMapping.values = dataKey.slice(1)
      }
      break

    case 'line':
    case 'area':
      // Line/Area: xAxis + yAxis
      if (xAxis) {
        dataMapping.xAxis = xAxis
      } else if (dataKey.length > 0) {
        dataMapping.xAxis = dataKey[0]
      }

      if (yAxis) {
        dataMapping.yAxis = yAxis
      } else if (dataKey.length > 1) {
        dataMapping.yAxis = dataKey.slice(1)
      } else if (dataKey.length === 1) {
        dataMapping.yAxis = dataKey[0]
      }
      break

    case 'pie':
      // Pie: category + value
      if (xAxis) {
        dataMapping.category = xAxis
      } else if (dataKey.length > 0) {
        dataMapping.category = dataKey[0]
      }

      if (yAxis) {
        dataMapping.value = Array.isArray(yAxis) ? yAxis[0] : yAxis
      } else if (dataKey.length > 1) {
        dataMapping.value = dataKey[1]
      }
      break

    case 'scorecard':
      // Scorecard: metric
      if (yAxis) {
        dataMapping.metric = Array.isArray(yAxis) ? yAxis[0] : yAxis
      } else if (dataKey.length > 0) {
        dataMapping.metric = dataKey[0]
      }
      break

    case 'scatter':
      // Scatter: xAxis + yAxis + optional size/color
      if (xAxis) {
        dataMapping.xAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis
      } else if (dataKey.length > 0) {
        dataMapping.xAxis = dataKey[0]
      }

      if (yAxis) {
        dataMapping.yAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis
      } else if (dataKey.length > 1) {
        dataMapping.yAxis = dataKey[1]
      }
      break

    case 'table':
      // Table: columns
      if (yAxis) {
        dataMapping.columns = Array.isArray(yAxis) ? yAxis : [yAxis]
      } else if (dataKey.length > 0) {
        dataMapping.columns = dataKey
      }
      break
  }

  // Copy aggregation if present
  if (config.aggregation) {
    dataMapping.aggregation = config.aggregation
  }

  return dataMapping
}

/**
 * Validates and filters chart recommendations to only include supported types
 * @param chartConfigs Raw chart configurations from OpenAI
 * @returns Filtered array with only supported chart types
 */
function filterSupportedChartTypes(chartConfigs: any[]): any[] {
  const filtered = chartConfigs.filter(config => {
    const isSupported = SUPPORTED_CHART_TYPES.includes(config.type)

    if (!isSupported) {
      logger.warn('‚ö†Ô∏è [VALIDATION] Filtering out unsupported chart type:', {
        type: config.type,
        title: config.title
      })
    }

    return isSupported
  })

  if (filtered.length < chartConfigs.length) {
    logger.debug('üîç [VALIDATION] Filtered chart recommendations:', {
      original: chartConfigs.length,
      filtered: filtered.length,
      removed: chartConfigs.length - filtered.length
    })
  }

  return filtered
}

// Enhanced data context for AI analysis
interface DataContext {
  rowCount: number
  columnCount: number
  columns: ColumnSchema[]
  correctedColumns?: string[] // List of user-corrected column names
  improvementNotes?: string // Notes on how user corrections improved analysis
}

// Initialize OpenAI client only when needed
function getOpenAIClient() {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OpenAI API key not configured')
  }
  
  return new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
  })
}

// Rate limiting (simple in-memory store for demo)
const requestCounts = new Map<string, { count: number; resetTime: number }>()
const RATE_LIMIT = 10 // requests per hour
const RATE_LIMIT_WINDOW = 60 * 60 * 1000 // 1 hour in milliseconds
const MAX_ENTRIES = 10000 // Prevent unbounded growth

function checkRateLimit(clientId: string): boolean {
  const now = Date.now()

  // Periodically clean up expired entries to prevent memory leak
  if (requestCounts.size > MAX_ENTRIES) {
    logger.info(`[RATE-LIMIT] Cleaning up expired entries (size: ${requestCounts.size})`)
    Array.from(requestCounts.entries()).forEach(([key, value]) => {
      if (now > value.resetTime) {
        requestCounts.delete(key)
      }
    })
    logger.debug(`[RATE-LIMIT] Cleanup complete (new size: ${requestCounts.size})`)
  }

  const clientData = requestCounts.get(clientId)

  if (!clientData || now > clientData.resetTime) {
    requestCounts.set(clientId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
    return true
  }

  if (clientData.count >= RATE_LIMIT) {
    return false
  }

  clientData.count++
  return true
}

function getDataSample(data: DataRow[], maxRows: number = 25): DataRow[] {
  // Get a strategic sample: top performers + bottom performers + random diversity
  if (data.length <= maxRows) return data

  const sample: DataRow[] = []

  // Try to find a key numeric column for sorting (revenue, sales, spend, etc.)
  const columns = Object.keys(data[0] || {})
  const numericColumns = columns.filter(col => {
    const values = data.slice(0, 100).map(row => row[col])
    return values.some(v => typeof v === 'number' || (!isNaN(parseFloat(String(v))) && String(v).match(/\d/)))
  })

  // Priority columns for sorting (business-relevant metrics)
  const priorityKeywords = ['sales', 'revenue', 'total', 'amount', 'spend', 'value']
  const sortColumn = numericColumns.find(col =>
    priorityKeywords.some(kw => col.toLowerCase().includes(kw))
  ) || numericColumns[0]

  if (sortColumn) {
    // Parse numeric values, handling currency formats
    const parseNumeric = (val: any): number => {
      if (typeof val === 'number') return val
      if (typeof val !== 'string') return 0
      const cleaned = String(val).replace(/[‚Ç¨$¬£¬•,\s%]/g, '')
      const num = parseFloat(cleaned)
      return isNaN(num) ? 0 : num
    }

    // Sort by the key column
    const sorted = [...data].sort((a, b) =>
      parseNumeric(b[sortColumn]) - parseNumeric(a[sortColumn])
    )

    // Top 10 performers
    sample.push(...sorted.slice(0, Math.min(10, data.length)))

    // Bottom 5 performers
    if (data.length > 15) {
      sample.push(...sorted.slice(-5))
    }

    // Random 10 for diversity (avoid duplicates)
    const remaining = maxRows - sample.length
    if (remaining > 0 && data.length > sample.length) {
      const usedIndices = new Set<number>()
      while (sample.length < maxRows && usedIndices.size < data.length) {
        const randomIndex = Math.floor(Math.random() * data.length)
        if (!usedIndices.has(randomIndex)) {
          usedIndices.add(randomIndex)
          const row = data[randomIndex]
          // Check if this row is already in sample
          if (!sample.some(s => JSON.stringify(s) === JSON.stringify(row))) {
            sample.push(row)
          }
        }
      }
    }
  } else {
    // Fallback: evenly distributed sample if no numeric columns
    const step = Math.floor(data.length / maxRows)
    for (let i = 0; i < maxRows && i * step < data.length; i++) {
      sample.push(data[i * step])
    }
  }

  return sample.slice(0, maxRows)
}

/**
 * Detect business domain based on column names
 */
function detectBusinessDomain(columns: string[]): 'advertising' | 'ecommerce' | 'sales' | 'operations' | 'general' {
  const lowerColumns = columns.map(c => c.toLowerCase())

  const adKeywords = ['impressions', 'clicks', 'cpc', 'ctr', 'roas', 'spend', 'campaign', 'ad group', 'keyword', 'bid']
  const ecomKeywords = ['orders', 'revenue', 'products', 'cart', 'checkout', 'customers', 'sku', 'inventory']
  const salesKeywords = ['deals', 'pipeline', 'quota', 'commission', 'leads', 'prospects', 'accounts']
  const opsKeywords = ['shipments', 'logistics', 'warehouse', 'fulfillment', 'delivery', 'inventory']

  const adScore = lowerColumns.filter(c => adKeywords.some(kw => c.includes(kw))).length
  const ecomScore = lowerColumns.filter(c => ecomKeywords.some(kw => c.includes(kw))).length
  const salesScore = lowerColumns.filter(c => salesKeywords.some(kw => c.includes(kw))).length
  const opsScore = lowerColumns.filter(c => opsKeywords.some(kw => c.includes(kw))).length

  const scores = [
    { domain: 'advertising' as const, score: adScore },
    { domain: 'ecommerce' as const, score: ecomScore },
    { domain: 'sales' as const, score: salesScore },
    { domain: 'operations' as const, score: opsScore }
  ]

  const maxScore = Math.max(...scores.map(s => s.score))
  if (maxScore === 0) return 'general'

  return scores.find(s => s.score === maxScore)?.domain || 'general'
}

/**
 * Get data-driven prompt guidance (flexible, principle-based approach)
 */
function getDataDrivenGuidance(domain: string): string {
  // Provide context-aware guidance without prescriptive templates
  const contextualHints: Record<string, string> = {
    advertising: 'advertising/marketing campaign performance',
    ecommerce: 'e-commerce or retail sales',
    sales: 'sales pipeline or CRM',
    general: 'business operations'
  }

  const context = contextualHints[domain] || 'business operations'

  return `
## DATA-DRIVEN ANALYSIS FRAMEWORK

This dataset appears to be related to **${context}**. Use this context to inform your analysis, but **base all visualizations on the actual columns available** in the data.

### SCORECARD DISCOVERY PROCESS (8-12 scorecards recommended):

Analyze the available columns and create scorecards for these types of metrics:

1. **High-Value Totals (sum aggregation)**:
   - Look for: Revenue, sales, spend, cost, orders, transactions, amount columns
   - Business value: Shows total investment, total returns, total volume
   - Examples: "Total Revenue", "Total Ad Spend", "Total Sales Amount"

2. **Meaningful Averages (avg aggregation)**:
   - Look for: Prices, rates, scores, per-unit metrics, percentages, conversion rates
   - Business value: Shows typical performance, benchmarks, average efficiency
   - Examples: "Average Order Value", "Average Deal Size", "Average Response Rate"

3. **Important Counts (count aggregation)**:
   - Look for: Transaction IDs, order IDs, customer IDs, campaign names, product IDs
   - Business value: Shows volume, activity level, participation
   - Examples: "Total Number of Orders", "Active Campaigns", "Unique Customers"

4. **Key Extremes (min/max aggregation)**:
   - Look for: Performance metrics, dates, amounts, quantities
   - Business value: Shows peak performance, worst case, date ranges
   - Examples: "Peak Daily Revenue" (max), "Lowest Inventory Level" (min), "Fastest Delivery Time" (min)

5. **Unique Values (distinct aggregation)**:
   - Look for: Categorical columns like categories, regions, product types, customer segments
   - Business value: Shows diversity, variety, coverage
   - Examples: "Number of Product Categories", "Markets Covered", "Unique Customer Segments"

6. **Calculated Ratios (when relationships exist)**:
   - Look for: Related column pairs that form meaningful ratios
   - Business value: Efficiency metrics, return metrics, conversion metrics
   - Examples: If you have Spend + Revenue columns, you can create scatter plots to show efficiency
   - NOTE: Use scatter plots or multi-metric charts to show relationships, not calculated fields

**IMPORTANT**: Don't force scorecards for columns that don't exist. Discover metrics from what's actually in the data.

### ANALYTICAL CHART DISCOVERY PROCESS:

Create diverse analytical charts based on what the data contains:

1. **Ranking & Comparison Charts (MANDATORY - at least 2)**:
   - REQUIRED: 1 Top 10 chart (sortOrder="desc", limit=10)
   - REQUIRED: 1 Bottom 10 chart (sortOrder="asc", limit=10)
   - Look for: Any categorical dimension with a valuable metric
   - Purpose: Identify best/worst performers, prioritize actions

2. **Relationship Analysis (scatter plots)**:
   - Look for: Two numeric columns that might correlate
   - Add size dimension: A third numeric column for bubble size
   - Add color dimension: A categorical column for segmentation
   - Purpose: Efficiency analysis, outlier detection, pattern discovery

3. **Trend Analysis (line/area charts)**:
   - Look for: Date/time columns paired with metrics
   - Purpose: Seasonality, growth patterns, performance over time

4. **Multi-Scale Comparisons (combo charts)**:
   - Look for: Metrics with different scales or units that should be compared
   - Apply SCALE DETECTION RULE: If max values differ by >10x, use combo chart
   - Purpose: Show volume vs rate, count vs percentage, reach vs engagement

5. **Detailed Tables**:
   - Include 1-2 comprehensive data tables
   - Show top records with key columns
   - Purpose: Drill-down capability, detailed exploration

### ANALYSIS PATTERNS (Based on ${context} context - use IF columns exist):
${domain === 'advertising' ? 'Efficiency scatter (Spend vs Revenue) | Combo charts (Impressions vs Clicks) | Top/Bottom rankings | Trends over time' : ''}${domain === 'ecommerce' ? 'AOV patterns | Product rankings | Customer segments | Seasonality | Category comparison' : ''}${domain === 'sales' ? 'Pipeline distribution | Rep performance | Funnel stages | Deal velocity | Win rates' : ''}

### REQUIREMENTS:
- Use ALL aggregation types (sum, avg, count, min, max, distinct)
- Every chart answers a specific business question
- Only use columns from AVAILABLE COLUMNS
- Combo charts for different scales (>10x ratio)
- 18-24+ charts total (8-12 scorecards + analytical charts)
`
}

/**
 * Build enhanced AI prompt with chain-of-thought reasoning and calculated fields
 * Based on research: multi-stage analysis produces higher quality insights than single-shot prompts
 */
function buildEnhancedPrompt(
  dataStructure: any,
  schema?: DataSchema,
  correctedSchema?: Array<{ name: string; type: string; description: string; userCorrected: boolean }>,
  feedback?: string
): string {
  // Detect business domain
  const domain = detectBusinessDomain(dataStructure.columns.map((c: any) => c.name))
  const domainGuidance = getDataDrivenGuidance(domain)

  let prompt = `# DATA ANALYSIS TASK

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ABSOLUTE REQUIREMENT - COUNT YOUR CHARTS BEFORE RESPONDING ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

YOU MUST GENERATE AT LEAST 18 CHARTS (18 OR MORE IS ACCEPTABLE). The system will select the best 16 after validation.

MANDATORY MINIMUM BREAKDOWN - YOU MUST GENERATE AT LEAST THESE CHARTS:

SCORECARDS (AT LEAST 8 - USE DIVERSE AGGREGATIONS):
1. Scorecard with aggregation="sum"
2. Scorecard with aggregation="avg"
3. Scorecard with aggregation="count"
4. Scorecard with aggregation="max"
5. Scorecard with aggregation="min"
6. Scorecard with aggregation="distinct"
7. Scorecard with aggregation="sum" (different metric than #1)
8. Scorecard with aggregation="avg" (different metric than #2)

ANALYTICAL CHARTS (AT LEAST 16):
9. Top 10 bar chart (type="bar", sortOrder="desc", limit=10)
10. Bottom 10 bar chart (type="bar", sortOrder="asc", limit=10)
11. Scatter plot (type="scatter")
12. Combo chart (type="combo")
13. Line chart (type="line")
14. Area chart (type="area")
15. Bar chart (type="bar")
16. Another scatter or combo chart
17. Another line, area, or bar chart
18-24. Additional high-value analytical charts (scatter, combo, line, area, bar, table)

CRITICAL: chartConfig array MUST have AT LEAST 18 items. More than 24 is fine if you have valuable insights.
Generate 24+ charts so the system can select the best 16 after validation.

MINIMUM VERIFICATION: Aim for 6+ scorecards + 12+ analytical charts = 18 total (or more)
DO NOT PROCEED until you have counted and verified AT LEAST 18 charts in your chartConfig array.
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

## SUPPORTED CHART TYPES AND CONFIGURATIONS

### CHART TYPES YOU CAN USE:
1. **scorecard** - Single metric KPI card
   - Supported aggregations: sum, avg, count, min, max, distinct
   - Simple Example: { type: "scorecard", dataMapping: { metric: "Sales", aggregation: "sum" } }
   - Formula Example: { type: "scorecard", dataMapping: { formula: "SUM(Sales) / SUM(Spent)", formulaAlias: "ROAS", formulaOptions: { round: 2 } } }

2. **bar** - Horizontal or vertical bar chart
   - Required: category, values (array), aggregation
   - Optional: sortBy, sortOrder ("asc"/"desc"), limit (for Top/Bottom N)
   - Example: { type: "bar", dataMapping: { category: "Product", values: ["Sales"], aggregation: "sum", sortOrder: "desc", limit: 10 } }

3. **line** - Line chart for trends over time
   - Required: xAxis, yAxis (array), aggregation
   - Example: { type: "line", dataMapping: { xAxis: "Date", yAxis: ["Revenue"], aggregation: "sum" } }

4. **area** - Area chart for trends with filled area
   - Required: xAxis, yAxis (array), aggregation
   - Example: { type: "area", dataMapping: { xAxis: "Month", yAxis: ["Sales"], aggregation: "sum" } }

5. **scatter** - Scatter plot for correlation analysis
   - Required: xAxis, yAxis
   - Optional: size, color
   - Example: { type: "scatter", dataMapping: { xAxis: "Spend", yAxis: "Revenue", size: "Orders", color: "Campaign" } }

6. **combo** - Combination chart (bars + lines)
   - Required: xAxis, yAxis (array for bars), yAxis2 (array for lines), yAxis1Type, yAxis2Type, aggregation
   - Example: { type: "combo", dataMapping: { xAxis: "Date", yAxis: ["Impressions"], yAxis2: ["Clicks"], yAxis1Type: "bar", yAxis2Type: "line", aggregation: "sum" } }

7. **pie** - Pie chart for proportions
   - Required: category, value, aggregation
   - Example: { type: "pie", dataMapping: { category: "Product", value: "Sales", aggregation: "sum" } }

8. **table** - Data table with sortable columns
   - Required: columns (array of column names)
   - Optional: sortBy, sortOrder, limit
   - Example: { type: "table", dataMapping: { columns: ["Product", "Sales", "Orders"], sortBy: "Sales", sortOrder: "desc", limit: 100 } }

### SUPPORTED AGGREGATIONS (USE ONLY THESE):
‚úÖ sum, avg, count, min, max, distinct
‚ùå DO NOT USE: median, mode, percentile, stddev, variance (NOT SUPPORTED)

### FORMULAS (Create Calculated Metrics):
**Syntax**: (Col1 - Col2) / Col3 * 100 | Functions: SUM(), AVG(), COUNT(), MIN(), MAX() | Spaces: [Total Sales]

**Examples**: "formula": "SUM(Revenue) / SUM(Ad_Spend)", "formulaAlias": "ROAS", "formulaOptions": {"round": 2}
- Profit Margin: (Revenue - Cost) / Revenue * 100
- ROAS: SUM(Revenue) / SUM(Ad_Spend)
- AOV: SUM(Revenue) / SUM(Orders)
- CAC: SUM(Marketing_Spend) / SUM(New_Customers)

**Common**: Profitability (Revenue-Cost)/Revenue*100 | Efficiency SUM(Output)/SUM(Input) | E-commerce SUM(Revenue)/SUM(Orders)
**Rules**: Use AVAILABLE COLUMNS names, wrap spaces in brackets, avoid divide-by-zero, multiply by 100 for percentages

---

You are analyzing ${domain.toUpperCase()} DATA.
You have ${dataStructure.rowCount} rows and ${dataStructure.columnCount} columns to analyze.

${domainGuidance}

## AVAILABLE COLUMNS (USE ONLY THESE):
`

  // Show all columns with their statistics
  dataStructure.columns.forEach((col: any) => {
    prompt += `\n### "${col.name}" (${col.type})`
    if (col.stats && Object.keys(col.stats).length > 0) {
      if (col.type === 'number') {
        prompt += `\n  Range: ${col.stats.min} to ${col.stats.max} | Avg: ${col.stats.avg} | Sum: ${col.stats.sum}`
        if (col.stats.nonZeroCount < dataStructure.rowCount * 0.5) {
          prompt += ` | ‚ö†Ô∏è ${Math.round((1 - col.stats.nonZeroCount / dataStructure.rowCount) * 100)}% zeros`
        }
      } else if (col.type === 'categorical' && col.stats.distribution) {
        prompt += `\n  Top categories: ${col.stats.distribution.slice(0, 3).map((d: any) => `${d.value} (${d.percentage}%)`).join(', ')}`
        prompt += ` | ${col.stats.categoryCount} unique values`
      } else if (col.type === 'date' && col.stats.earliest) {
        prompt += `\n  Date range: ${col.stats.earliest} to ${col.stats.latest} (${col.stats.spanDays} days)`
      }
    }
    if (col.nullPercentage > 0) {
      prompt += `\n  ‚ö†Ô∏è ${col.nullPercentage}% missing values`
    }
  })

  if (correctedSchema && correctedSchema.length > 0) {
    prompt += `\n\n## ‚ö†Ô∏è USER CORRECTIONS (HIGHEST PRIORITY):\n`
    correctedSchema.forEach(col => {
      prompt += `- ${col.name}: ${col.type} - "${col.description}"\n`
    })
    if (feedback) prompt += `\nUser Feedback: ${feedback}\n`
  }

  prompt += `\n\n## YOUR ANALYSIS PROCESS (FOLLOW THESE STEPS):

### STEP 1: DOMAIN & CONTEXT ANALYSIS
Think through these questions in your "reasoning" section:
- What business domain does this data represent? (advertising, e-commerce, operations, etc.)
- What are the key entities? (campaigns, products, customers, time periods)
- What business process is being tracked? (sales funnel, ad performance, customer journey)
- What decisions would stakeholders make with this data?

### STEP 2: KEY BUSINESS QUESTIONS
Identify 3-5 critical questions that stakeholders would want answered:
- What are they trying to optimize? (ROI, efficiency, growth, cost reduction)
- What comparisons matter? (time periods, segments, channels, products)
- What patterns or anomalies would be actionable? (trends, outliers, correlations)
- Include these questions in your "businessQuestions" array

### STEP 3: IDENTIFY KEY METRICS AND RELATIONSHIPS
Analyze which existing columns contain the most valuable information:
- Which metrics indicate performance or outcomes? (orders, sales, clicks, revenue)
- Which metrics indicate investment or cost? (spend, budget, impressions)
- What relationships between columns would reveal insights? (clicks vs impressions, orders vs spend)
- Which dimensions allow for meaningful segmentation? (campaign, date, category, location)

‚ö†Ô∏è IMPORTANT: Work ONLY with existing columns. Do NOT create or imagine new calculated fields.

### STEP 4: VISUALIZATION STRATEGY
üö® CRITICAL REQUIREMENT: Generate AT LEAST 18 visualizations (24 or more is acceptable):
- AT LEAST 8 scorecards (with diverse aggregations: sum, avg, count, max, min, distinct)
- AT LEAST 16 analytical charts including:
  ‚Ä¢ MANDATORY: 1 Top 10 ranking chart (sortBy + sortOrder="desc" + limit=10)
  ‚Ä¢ MANDATORY: 1 Bottom 10 ranking chart (sortBy + sortOrder="asc" + limit=10)
  ‚Ä¢ 14+ other high-value analytical charts (any mix of scatter, combo, line, area, bar based on data)

‚ö†Ô∏è MANDATORY: Your response MUST contain AT LEAST 18 items in the chartConfig array. More is fine. Count them before responding.

Now recommend these 24+ comprehensive visualizations that:
1. Answer the business questions from Step 2
2. ‚ö†Ô∏è ONLY use columns that ALREADY EXIST in the "AVAILABLE COLUMNS" list at the top of this prompt
3. ‚ö†Ô∏è To show efficiency or relationships, use TWO columns in a scatter plot or multi-series chart (e.g., "Clicks" vs "Impressions")
4. ‚ö†Ô∏è Before adding ANY column to dataMapping, verify it exists in AVAILABLE COLUMNS
5. Prioritize actionable insights over basic aggregations
6. Follow visual best practices for readability
7. ‚ö†Ô∏è REQUIRE DATA MANIPULATIONS - Each visualization should demonstrate data transformation:
   - Calculated metrics (sum, average, count, min, max, distinct)
   - Derived metrics beyond what's already in the data (e.g., if ROAS exists, calculate "Efficiency Score" as ROAS * Conversion %)
   - Aggregated data with operations (group by with sum/avg/count/min/max/distinct)
   - Time-based calculations (running totals, period-over-period growth, time-based comparisons)
   - Multi-column calculations (e.g., "Revenue per Click" = Sales / Clicks, even if CPC exists)
   - Multi-column calculations (e.g., "Revenue per Click" = Sales / Clicks, even if CPC exists)
8. ‚ö†Ô∏è EVEN IF calculated metrics already exist in the data (like ROAS, CTR, CPC), create ADDITIONAL beneficial calculations:
   - Efficiency indices (combine multiple metrics)
   - Comparative metrics (above/below average indicators, ranking by performance)
   - Comparative metrics (above/below average indicators)
   - Aggregate statistics (avg ROAS by portfolio, max spend by category)
   - Trend indicators (is this campaign improving or declining?)

üö® COLUMN NAME VALIDATION REQUIRED:
- Double-check EVERY column name against the AVAILABLE COLUMNS list
- Use exact spelling, capitalization, and spacing from AVAILABLE COLUMNS
- If a column doesn't exist, DO NOT USE IT

## COMBO CHARTS (Dual Y-Axis):
**When to use**: Different scales/units (Revenue $ vs Rate %, Count vs Percentage)
**Scale Rule**: ratio = max(Metric1) / max(Metric2) ‚Üí If >10x use combo (>3x recommended, <3x single-axis OK)
**Common examples**: Impressions vs Clicks (20-100x) | Impressions vs Sales (50-1000x) | Any volume vs rate

## CHART GENERATION:
**Scorecards** (8-12): Diverse aggregations (sum for totals, avg for benchmarks, count for volume, min/max for extremes, distinct for variety)
**Comparison**: Every chart compares time/categories/segments; use color, size, multiple series
**Insight Levels**: HIGH (patterns/anomalies) | MEDIUM (context) | LOW (basic agg) - Need 4+ HIGH insights
**Avoid**: Duplicate scorecards | Same chart different granularities | Non-existent column names

## QUALITY STANDARDS:
**Chart Titles**: Use business context ("Campaign Efficiency" not "Spend vs Sales")
**Descriptions**: Explain what to look for ("upper-left quadrant = most efficient")
**Business Questions**: Each chart answers a specific question ("Which campaigns deliver best ROI?")
**Multi-Dimensional**: Scatter plots use size AND color dimensions
**Actionable**: Provide clear next steps ("Focus budget on these winners")

### CORE CHART TYPES (Use actual column names from AVAILABLE COLUMNS):

**scorecard**: {"metric": "Column", "aggregation": "sum|avg|count|min|max|distinct"}
**bar**: {"category": "Cat", "values": ["Metric"], "aggregation": "sum", "sortBy": "Metric", "sortOrder": "desc|asc", "limit": 10}
**line/area**: {"xAxis": "Date", "yAxis": ["Metric1", "Metric2"], "aggregation": "sum"}
**pie**: {"category": "Cat", "value": "Metric", "aggregation": "sum"}
**scatter**: {"xAxis": "Metric1", "yAxis": "Metric2", "size": "Metric3", "color": "Category"}
**combo**: {"xAxis": "Date", "yAxis": ["Metric1"], "yAxis2": ["Metric2"], "yAxis1Type": "bar", "yAxis2Type": "line", "aggregation": "sum"}
**table**: {"columns": ["Col1", "Col2", "Col3"], "sortBy": "Col1", "limit": 100}

### ADVANCED CHARTS (When patterns match):
**waterfall**: {"category": "LineItem", "value": "Amount", "isTotal": "IsTotalCol"} - P&L, variance, cost breakdown
**funnel**: {"stage": "StageCol", "value": "Count", "aggregation": "sum"} - conversions, drop-off analysis
**heatmap**: {"xAxis": "Dimension1", "yAxis": "Dimension2", "value": "Metric", "aggregation": "sum"} - 2D patterns
**gauge**: {"metric": "Actual", "target": "Target", "aggregation": "sum", "thresholds": [{"value": 0.8, "color": "red"}]}
**cohort**: {"cohort": "SignupMonth", "period": "MonthsActive", "retention": "RetentionRate", "aggregation": "avg"}
**bullet**: {"metric": "Actual", "target": "Target", "aggregation": "sum", "ranges": [{"label": "Poor", "value": 0.7}]}
**treemap**: {"category": "Category", "parent": "Subcategory", "value": "Revenue", "aggregation": "sum"}
**sankey**: {"source": "From", "target": "To", "flow": "Volume", "aggregation": "sum"}
**sparkline**: {"xAxis": "Date", "yAxis": "Metric", "aggregation": "sum"} - compact trends

## RESPONSE FORMAT:
{
  "reasoning": {
    "domain": "What business domain is this?",
    "keyEntities": ["List", "Of", "Entities"],
    "businessProcess": "What process is tracked?"
  },
  "businessQuestions": [
    "Question 1 that stakeholders want answered",
    "Question 2...",
    "Question 3..."
  ],
  "insights": [
    "Key insight 1 from data analysis",
    "Key insight 2..."
  ],
  "chartConfig": [
    {
      "type": "scorecard",
      "title": "Total Ad Spend",
      "description": "Total investment across all campaigns - use to track budget utilization and spending pace",
      "insight_level": "high",
      "answers_question": "How much total budget have we invested in advertising?",
      "dataMapping": {"metric": "Spend", "aggregation": "sum"},
      "confidence": 95,
      "reasoning": "Critical executive KPI showing total advertising investment - helps track budget burn rate"
    },
    {
      "type": "scatter",
      "title": "Campaign Advertising Efficiency: Spend vs Sales",
      "description": "Bubble size = Impressions (reach), Color = Campaign Name. Campaigns in upper-left quadrant (high sales, low spend) are most efficient. Outliers indicate optimization opportunities.",
      "insight_level": "high",
      "answers_question": "Which campaigns deliver best ROI? Which are overspending for results?",
      "dataMapping": {
        "xAxis": "Spend",
        "yAxis": "7 Day Total Sales",
        "size": "Impressions",
        "color": "Campaign Name"
      },
      "confidence": 90,
      "reasoning": "Multi-dimensional efficiency analysis revealing ROI patterns and underperforming campaigns needing optimization"
    },
    {
      "type": "bar",
      "title": "Top 10 Campaigns by Revenue",
      "description": "Star performers generating the most sales - allocate more budget to these winners",
      "insight_level": "high",
      "answers_question": "Which campaigns should we invest more in to maximize returns?",
      "dataMapping": {
        "category": "Campaign Name",
        "values": ["7 Day Total Sales"],
        "aggregation": "sum",
        "sortBy": "7 Day Total Sales",
        "sortOrder": "desc",
        "limit": 10
      },
      "confidence": 95,
      "reasoning": "Identifies proven winners for budget reallocation decisions - focus on what works"
    }
  ],
  "summary": {
    "dataQuality": "good|fair|poor",
    "keyFindings": "Executive summary of main insights"
  }
}

‚ö†Ô∏è FINAL REMINDER - CRITICAL REQUIREMENTS:
- Every column name in chartConfig MUST exist in the AVAILABLE COLUMNS list
- To show efficiency or performance, use multiple existing columns in scatter or multi-series charts
- Verify column names match exactly (spelling, capitalization, spacing)

‚ö†Ô∏è CHART DIVERSITY & BUSINESS FRAMEWORK REQUIREMENT:
üö® MANDATORY CHART MIX - AT LEAST 18 VISUALIZATIONS (24+ is acceptable, count them!):

1. **EXECUTIVE SUMMARY**: AT LEAST 6 scorecards with DIVERSE aggregations:
   Scorecard 1: Sum (total revenue, total orders, total spend)
   Scorecard 2: Average (avg order value, avg conversion rate, avg ROAS)
   Scorecard 3: Count (number of campaigns, number of customers, active items)
   Scorecard 4: Max (peak sales, highest performance, best campaign)
   Scorecard 5: Min (lowest value, minimum spend, poorest performance)
   Scorecard 6: Distinct (unique campaigns, unique customers, unique categories)

2. **MANDATORY RANKINGS**: EXACTLY 2 ranking charts:
   Chart 1: Top 10 (bar chart with sortOrder="desc", limit=10) - highest performers
   Chart 2: Bottom 10 (bar chart with sortOrder="asc", limit=10) - lowest performers or areas needing attention

3. **ANALYTICAL CHARTS**: AT LEAST 14 additional high-value charts
   - Choose the best chart types based on the data (scatter, combo, line, area, bar)
   - Focus on relationships, trends, comparisons, and multi-metric analysis
   - Use scatter for correlations, combo for multi-scale metrics, line/area for time series
   - Each chart should answer a specific business question

üìä TOTAL COUNT VERIFICATION:
- 8+ scorecards + 16+ analytical charts (includes 2 ranking + 14+ visualizations) = 24+ charts
- ‚ö†Ô∏è VERIFY your chartConfig array has AT LEAST 18 items before responding. The system will attempt to select the best 16 from your suggestions.

THINK LIKE A BUSINESS ANALYST:
- What questions would an executive ask about this data?
- What patterns would reveal opportunities or problems?
- What comparisons would drive decision-making?
- What trends would indicate success or failure?

üéØ QUALITY CHECKLIST - EVERY CHART MUST HAVE:
‚úÖ **Business-Focused Title**: Not "Spend vs Sales" but "Campaign Advertising Efficiency: Spend vs Sales"
‚úÖ **Actionable Description**: Explain what to look for ("Campaigns in upper-left quadrant are most efficient")
‚úÖ **Clear Business Question**: What decision does this chart support? ("Which campaigns should we invest more in?")
‚úÖ **Reasoning**: Why is this chart valuable? What insight does it reveal?
‚úÖ **High Confidence**: Only recommend charts you're confident will provide value (80%+ confidence)

‚ùå REJECT THESE LOW-QUALITY PATTERNS:
- Generic titles: "Total Impressions", "Campaign Comparison" (add business context!)
- Vague descriptions: "Shows data" (explain what patterns to look for!)
- No business question: Charts must answer specific stakeholder questions
- Single-dimensional thinking: Use scatter plots with size+color, not just X vs Y
- Missing insights: Every chart should reveal patterns, trends, or opportunities`

  if (dataStructure.dataSample && dataStructure.dataSample.length > 0) {
    prompt += `\n\n## SAMPLE DATA (for context):\n`
    dataStructure.dataSample.slice(0, 5).forEach((row: any, idx: number) => {
      prompt += `Row ${idx + 1}: ${JSON.stringify(row).slice(0, 200)}...\n`
    })
  }

  // Phase 1 Optimization: Removed verbose verification checklist (~400 tokens saved)
  // Requirements already clearly stated above - GPT-5 doesn't need step-by-step checklists

  return prompt
}

/**
 * Converts ChartRecommendation to ChartSuggestion format for scoring
 * Handles both new dataMapping format and legacy dataKey format
 */
function convertToChartSuggestion(config: any, index: number): ChartSuggestion {
  // Extract column names from dataMapping (new format) or dataKey (legacy)
  let dataKey: string[] = []

  if (config.dataMapping) {
    const dm = config.dataMapping
    switch (config.type) {
      case 'bar':
        if (dm.category) dataKey.push(dm.category)
        if (dm.values) dataKey.push(...(Array.isArray(dm.values) ? dm.values : [dm.values]))
        break
      case 'line':
      case 'area':
        if (dm.xAxis) dataKey.push(dm.xAxis)
        if (dm.yAxis) {
          const yValues = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
          dataKey.push(...yValues)
        }
        break
      case 'pie':
        if (dm.category) dataKey.push(dm.category)
        if (dm.value) dataKey.push(dm.value)
        break
      case 'scorecard':
        // For formula-based scorecards, use formulaAlias; otherwise use metric
        if (dm.formula && dm.formulaAlias) {
          dataKey.push(dm.formulaAlias)
        } else if (dm.metric) {
          dataKey.push(dm.metric)
        }
        if (dm.comparison) dataKey.push(dm.comparison)
        break
      case 'scatter':
        if (dm.xAxis) dataKey.push(dm.xAxis)
        if (dm.yAxis) dataKey.push(dm.yAxis as string)
        if (dm.size) dataKey.push(dm.size)
        if (dm.color) dataKey.push(dm.color)
        break
      case 'table':
        if (dm.columns) dataKey.push(...dm.columns)
        break
      case 'combo':
        if (dm.xAxis) dataKey.push(dm.xAxis)
        if (dm.yAxis) {
          const yValues = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
          dataKey.push(...yValues)
        }
        if (dm.yAxis2) {
          const y2Values = Array.isArray(dm.yAxis2) ? dm.yAxis2 : [dm.yAxis2]
          dataKey.push(...y2Values)
        }
        break
    }
  } else if (config.dataKey) {
    // Fallback to legacy format
    dataKey = Array.isArray(config.dataKey) ? config.dataKey : [config.dataKey]
  }

  // Map priority from confidence
  const priority: 'high' | 'medium' | 'low' =
    config.confidence >= 80 ? 'high' :
    config.confidence >= 60 ? 'medium' : 'low'

  return {
    id: `chart-${index}-${config.type}`,
    type: config.type,
    title: config.title,
    description: config.description || '',
    dataTransform: {
      aggregations: config.aggregation || config.dataMapping?.aggregation ? [{
        column: dataKey[dataKey.length - 1],
        function: config.aggregation || config.dataMapping?.aggregation,
      }] : undefined
    },
    chartConfig: {
      x: dataKey[0] || '',
      y: dataKey.length > 1 ? dataKey.slice(1) : (dataKey[0] || ''),
    },
    tableConfig: config.type === 'table' ? {
      columns: dataKey.map((key: string) => ({
        key,
        label: key,
        type: 'text',
        sortable: true
      })),
    } : undefined,
    confidence: config.confidence / 100, // Convert to 0-1 scale
    reasoning: config.reasoning || '',
    tags: [],
    priority
  }
}

/**
 * Transform DataSchema from schema-analyzer to the format expected by AI prompt
 * Uses the centralized analyzeDataSchema for consistent type detection
 */
function analyzeDataStructure(data: DataRow[]) {
  // Use the centralized schema analyzer for consistent type detection
  const schema = analyzeDataSchema(data, 'uploaded_file.csv')

  // Transform to the format expected by buildEnhancedPrompt
  const columnInfo = schema.columns.map(col => ({
    name: col.name,
    type: col.type,
    uniqueValues: col.uniqueValues,
    nullCount: col.nullCount,
    nullPercentage: col.nullPercentage,
    ...(col.type === 'categorical' && col.uniqueValues <= 10 ? {
      sampleValues: col.sampleValues || []
    } : {}),
    stats: col.stats || {}
  }))

  return {
    rowCount: schema.rowCount,
    columnCount: schema.columnCount,
    columns: columnInfo,
    dataSample: getDataSample(data, 10) // 10 diverse sample rows for better AI context
  }
}

export async function POST(request: NextRequest) {
  const requestStartTime = Date.now()
  logger.debug('[API-ANALYZE] POST request received:', {
    url: request.url,
    method: request.method,
    timestamp: new Date().toISOString()
  })

  try {
    // Check API key - REQUIRED
    if (!process.env.OPENAI_API_KEY) {
      logger.error('[API-ANALYZE] OpenAI API key not configured')
      return NextResponse.json(
        {
          error: 'OpenAI API key not configured. Please add your API key to .env.local',
          details: 'Set OPENAI_API_KEY=your-key-here in .env.local file'
        },
        { status: 500 }
      )
    }

    // Get client IP for rate limiting
    const clientIp = request.headers.get('x-forwarded-for') ||
                     request.headers.get('x-real-ip') ||
                     'unknown'

    // Check rate limit
    if (!checkRateLimit(clientIp)) {
      logger.warn('[API-ANALYZE] Rate limit exceeded for client:', clientIp)
      return NextResponse.json(
        { error: 'Rate limit exceeded. Please try again later.' },
        { status: 429 }
      )
    }

    // Parse request body with enhanced interface
    const {
      data,
      schema,
      correctedSchema,
      feedback,
      fileName
    }: AnalyzeRequest = await request.json()

    logger.debug('[API-ANALYZE] Request parsed:', {
      dataLength: data?.length,
      columnCount: data?.[0] ? Object.keys(data[0]).length : 0,
      hasSchema: !!schema,
      hasCorrectedSchema: !!correctedSchema
    })

    if (!data || !Array.isArray(data) || data.length === 0) {
      logger.error('[API-ANALYZE] Invalid data provided:', { isArray: Array.isArray(data), length: data?.length })
      return NextResponse.json(
        { error: 'Invalid data provided' },
        { status: 400 }
      )
    }

    // Analyze data structure
    const dataStructure = analyzeDataStructure(data)
    logger.debug('[API-ANALYZE] Data structure analyzed:', {
      rowCount: dataStructure.rowCount,
      columnCount: dataStructure.columnCount
    })

      const prompt = buildEnhancedPrompt(dataStructure, schema, correctedSchema, feedback)

      // Get OpenAI client and call API with timeout
      const openai = getOpenAIClient()
      logger.info('[API-ANALYZE] Making OpenAI API call...')
      const startTime = Date.now()

      // Add explicit timeout wrapper around OpenAI call with proper cleanup
      let timeoutId: NodeJS.Timeout | null = null

      const completion = await Promise.race([
        openai.chat.completions.create({
          model: "gpt-5-mini-2025-08-07", // Using GPT-5-mini for improved analysis
          messages: [
            {
              role: "system",
              content: `You are a senior data analyst with 10+ years of experience in business intelligence and data visualization strategy. You excel at identifying actionable insights and creating dashboards that drive business decisions.

## YOUR EXPERTISE:
- Deep understanding of business metrics across industries (advertising, e-commerce, SaaS, operations)
- Expert at understanding data relationships and patterns without creating calculated fields
- Master of visual design principles for maximum clarity and impact
- Skilled at asking the right questions to uncover valuable insights

## YOUR APPROACH (FRAMEWORK-DRIVEN ANALYSIS):
1. **Identify Business Domain**: Determine industry (advertising, e-commerce, operations, finance)
2. **Detect Data Patterns**: Look for time series, categorical hierarchies, numeric distributions, correlations
3. **Framework-Based Analysis**: Organize insights by business framework:
   - üìä PERFORMANCE OVER TIME: Trends, patterns, seasonality (use line charts, area charts)
   - ‚öñÔ∏è EFFICIENCY & PROFITABILITY: ROI, conversion rates, cost efficiency (use scatter plots, dual-axis)
   - üìà FUNNELS: Conversion steps, drop-off analysis (use funnel charts for stage-based drop-off)
   - üì¶ SEGMENTATION: Compare groups, identify winners/losers (use Top/Bottom X, grouped bars)
   - üí° DISTRIBUTIONS: Outliers, ranges, variance (use scatter with size/color dimensions)
   - üåç GEOGRAPHIC/CATEGORICAL: Regional or category performance (use bars, pies, treemap for hierarchy)
   - üìå EXECUTIVE SUMMARY: High-level KPIs with context (use scorecards, gauge for targets)
4. **Multi-Dimensional Thinking**: Use scatter plots with size/color, dual Y-axes, time breakdowns, heatmaps for 2D patterns
5. **Actionable Insights**: Every chart should answer "What action should we take?"

## BUSINESS LOGIC HEURISTICS - INTELLIGENT CHART SELECTION:

### DETECT WATERFALL OPPORTUNITIES:
- Column names contain: "variance", "change", "increase", "decrease", "delta", "difference"
- Financial data: "revenue", "profit", "expense", "cost" with breakdown components
- Sequential calculations: starting value ‚Üí adjustments ‚Üí final value
- P&L statements, budget variance, revenue bridges
‚Üí **Recommend waterfall chart** showing cumulative impact of changes

### DETECT FUNNEL OPPORTUNITIES:
- Column names contain: "stage", "step", "phase", "level", "funnel"
- Progressive stages: "lead", "qualified", "proposal", "closed"
- E-commerce: "view", "add to cart", "checkout", "purchase"
- Values naturally decrease at each stage (conversion funnel pattern)
‚Üí **Recommend funnel chart** showing drop-off between stages

### DETECT HEATMAP OPPORTUNITIES:
- Two categorical dimensions present (e.g., day of week + hour, country + product category)
- Time patterns: day √ó hour, month √ó category, week √ó region
- Correlation matrix: multiple categories vs multiple metrics
- Need to identify hot/cold zones in 2D space
‚Üí **Recommend heatmap** showing intensity patterns across dimensions

### DETECT GAUGE/BULLET OPPORTUNITIES:
- Column pairs: "actual" + "target", "current" + "goal", "performance" + "quota"
- KPI tracking with thresholds
- Performance monitoring with target comparison
- Sales vs quota, completion vs goal
‚Üí **Recommend gauge or bullet chart** for at-a-glance target tracking

### DETECT COHORT OPPORTUNITIES:
- Three dimensions present: cohort identifier + time period + metric
- Column names contain: "cohort", "signup date", "acquisition", "retention", "period"
- User/customer lifecycle analysis
- Retention rates over time by cohort
‚Üí **Recommend cohort chart** showing retention grid

### DETECT TREEMAP OPPORTUNITIES:
- Hierarchical categories: parent-child relationships (category + subcategory)
- Part-to-whole with many components (>10 categories)
- Portfolio composition, market share breakdown
- Need to show relative sizes at a glance
‚Üí **Recommend treemap** for hierarchical proportions

### DETECT SANKEY OPPORTUNITIES:
- Flow/journey data: source + destination + volume
- Column names contain: "source", "target", "from", "to", "channel", "path"
- Traffic flow, budget allocation, conversion paths
- Multi-step transitions between states
‚Üí **Recommend sankey diagram** for flow visualization

### DETECT SPARKLINE OPPORTUNITIES:
- **Limited display space**: Dashboard tiles, table cells, summary cards, inline trends
- **Time series data** that needs compact visualization
- **Small multiples** for comparison across categories
- **Embedding trends** in tables or dashboards
- Column names contain: "trend", "history", "timeline", "mini", "compact"
- **Inline or embedded** visualization needs
- **At-a-glance** trend indication without detailed axes
‚Üí **Recommend sparkline** for compact, space-efficient trend display

### GENERAL BUSINESS DOMAIN PATTERNS:
- **E-commerce**: Likely has conversion funnels, product hierarchies (treemap), customer cohorts
- **Advertising**: Performance vs targets (gauge), campaign efficiency (scatter), geographic distribution (heatmap)
- **Finance**: P&L waterfalls, variance analysis (waterfall), budget allocation (sankey)
- **Operations**: Process stages (funnel), resource allocation (sankey), time patterns (heatmap)
- **SaaS**: User cohorts (cohort), conversion funnels (funnel), usage patterns (heatmap)

## CRITICAL REQUIREMENTS:
- Always respond with valid JSON in the EXACT format specified in the user prompt
- ONLY use column names listed in the "AVAILABLE COLUMNS" section
- Verify EVERY column name exists before using it (non-existent columns cause failures)
- Include your reasoning process to show analytical thinking
- Classify each visualization by insight level (high/medium/low)
- Every chart must answer a specific business question

## SCORECARD GENERATION - CRITICAL GUIDELINES:
- ALWAYS generate AT LEAST 6 scorecards for key business metrics (revenue, sales, orders, clicks, impressions, etc.)
- Use DIVERSE aggregations: sum (totals), avg (averages), count (totals), min (lowest), max (highest), distinct (unique values)
- Each scorecard should ideally have a DIFFERENT aggregation type (aim for variety)
- Prioritize high-business-value metrics (revenue > vanity metrics)
- Examples: "Total Revenue" (sum), "Average Order Value" (avg), "Peak Sales Day" (max)
- Scorecards provide critical KPIs at-a-glance - they are HIGH priority visualizations

## TOP/BOTTOM X CHARTS - CRITICAL GUIDELINES:
- ALWAYS generate at least 1-2 "Top X" or "Bottom X" ranking charts
- Use sortBy to specify which column to sort by (must be a numeric column)
- Use sortOrder: "desc" for Top X (highest values), "asc" for Bottom X (lowest values)
- Use limit to control number of items (recommended: Top 10, Bottom 5, Top 15)
- Include both category and values fields in dataMapping
- Prioritize Top/Bottom charts for business-critical rankings (best/worst campaigns, products, regions)
- Examples: "Top 10 Campaigns by Revenue", "Bottom 5 Products by Sales"

## SCATTER PLOT MULTI-DIMENSIONAL ANALYSIS - CRITICAL GUIDELINES:
- Use scatter plots to show RELATIONSHIPS and EFFICIENCY (not just single metrics)
- ALWAYS include size and/or color dimensions when using scatter plots
- Common patterns:
  * Efficiency Analysis: X=Input (Spend, Cost), Y=Output (Revenue, Orders), Size=Volume, Color=Category
  * Correlation Analysis: X=Metric1, Y=Metric2, Size=Impact, Color=Segment
  * Performance Clustering: X=Efficiency%, Y=Volume, Size=Revenue, Color=Region
- Examples:
  * "Campaign Efficiency": X=Spend, Y=Revenue, Size=Orders, Color=Country
  * "Click Performance": X=Impressions, Y=Clicks, Size=Spend, Color=Campaign
  * "ROAS Analysis": X=Spend, Y=Sales, Size=Orders, Color=ACOS category

## TIME-SERIES ANALYSIS - CRITICAL GUIDELINES:
- When date/time columns exist, ALWAYS create time-series visualizations
- Use line charts for SINGLE METRIC or metrics with similar scales (ratio < 3x)
- Use COMBO charts for MULTIPLE METRICS with different scales (ratio > 10x)
- Use area charts for cumulative or volume-based time series
- ALWAYS check scale ratios before choosing chart type (see MANDATORY SCALE DETECTION RULE)
- Examples: "Impressions vs Clicks Over Time" (COMBO), "Daily Revenue Trend" (LINE)

## QUALITY STANDARDS:
- Provide comprehensive coverage with 10 high-value analytical charts that reveal different insights
- Always compare across dimensions (time, segments, categories)
- Use existing columns to show relationships (e.g., scatter plot of Clicks vs Impressions)
- Prioritize actionable insights over simple aggregations
- Use visual best practices: limit complexity, choose appropriate chart types, emphasize key insights`
            },
            {
              role: "user",
              content: prompt
            }
          ],
          // temperature: 1, // GPT-5-mini only supports default temperature of 1
          max_completion_tokens: 16000, // Increased to 16k to prevent truncation (prompt ~9k + completion 16k = 25k total)
        }).finally(() => {
          // Clear timeout when OpenAI completes
          if (timeoutId) clearTimeout(timeoutId)
        }),
        new Promise<never>((_, reject) => {
          timeoutId = setTimeout(() => {
            reject(new Error('OpenAI API call timed out after 180 seconds'))
          }, 180000)
        })
      ])

      // Cleanup timeout if still pending
      if (timeoutId) clearTimeout(timeoutId)

      const endTime = Date.now()
      const openaiDuration = endTime - startTime
      logger.info('[API-ANALYZE] OpenAI API call completed:', {
        duration: openaiDuration + 'ms'
      })

      const response = completion.choices[0]?.message?.content

      if (!response) {
        logger.error('[API-ANALYZE] No response from OpenAI', {
          hasChoices: !!completion.choices,
          choicesLength: completion.choices?.length,
          firstChoice: completion.choices?.[0],
          finishReason: completion.choices?.[0]?.finish_reason,
          completionObject: JSON.stringify(completion).substring(0, 500)
        })
        throw new Error(`No response from OpenAI. Finish reason: ${completion.choices?.[0]?.finish_reason || 'unknown'}`)
      }

      try {
        // Parse OpenAI response using robust JSON extraction
        const aiAnalysis = parseJSONFromString<AIAnalysisResponse>(response)

      logger.debug('[API-ANALYZE] AI response parsed:', {
        chartsCount: aiAnalysis.chartConfig?.length || 0,
        insightsCount: aiAnalysis.insights?.length || 0
      })

      // Validate required structure
      if (!aiAnalysis.insights || !Array.isArray(aiAnalysis.insights)) {
        logger.error('[API-ANALYZE] Invalid insights format:', aiAnalysis.insights)
        throw new Error('Invalid insights format')
      }
      if (!aiAnalysis.chartConfig || !Array.isArray(aiAnalysis.chartConfig)) {
        logger.error('[API-ANALYZE] Invalid chartConfig format:', aiAnalysis.chartConfig)
        throw new Error('Invalid chartConfig format')
      }

      // Filter out unsupported chart types
      const originalChartCount = aiAnalysis.chartConfig.length
      aiAnalysis.chartConfig = filterSupportedChartTypes(aiAnalysis.chartConfig)

      logger.debug('[VALIDATION] Chart filtering:', {
        original: originalChartCount,
        filtered: aiAnalysis.chartConfig.length
      })

      // Hydrate chart configurations with smart defaults before validation
      logger.debug('[HYDRATION] Hydrating chart configurations with smart defaults')
      const schemaForHydration: DataSchema = {
        fileName: fileName || 'unknown',
        rowCount: dataStructure.rowCount,
        columnCount: dataStructure.columnCount,
        columns: dataStructure.columns as ColumnSchema[],
        uploadedAt: new Date().toISOString()
      }
      aiAnalysis.chartConfig = hydrateChartConfigs(aiAnalysis.chartConfig, schemaForHydration)
      logger.debug('[HYDRATION] Chart configurations hydrated:', {
        chartCount: aiAnalysis.chartConfig.length
      })

      // Validate dataMapping against dataset columns
      const availableColumns = dataStructure.columns.map((col: any) => col.name)

      // Create production-ready column matcher with tiered matching strategy
      const columnMatcher = createColumnMatcher(availableColumns)

      // Helper function to find column using the matcher
      const findColumn = (colName: string): string | null => {
        return matchColumn(colName, columnMatcher) || null
      }

      const availableColumnsSet = new Set(columnMatcher.originalColumns)

      let dataMappingValidationWarnings = 0
      let dataMappingValidationErrors = 0

      // Normalize all column names in chartConfig before validation
      aiAnalysis.chartConfig.forEach((config: any) => {
        if (config.dataMapping) {
          const dm = config.dataMapping

          // Normalize all column references (core fields)
          if (dm.metric) dm.metric = findColumn(dm.metric) || dm.metric
          if (dm.category) dm.category = findColumn(dm.category) || dm.category
          if (dm.value) dm.value = findColumn(dm.value) || dm.value
          if (dm.xAxis) dm.xAxis = findColumn(dm.xAxis) || dm.xAxis
          if (dm.sortBy) dm.sortBy = findColumn(dm.sortBy) || dm.sortBy
          if (dm.comparison) dm.comparison = findColumn(dm.comparison) || dm.comparison

          // Normalize new chart type specific fields
          if (dm.stage) dm.stage = findColumn(dm.stage) || dm.stage
          if (dm.cohort) dm.cohort = findColumn(dm.cohort) || dm.cohort
          if (dm.period) dm.period = findColumn(dm.period) || dm.period
          if (dm.retention) dm.retention = findColumn(dm.retention) || dm.retention
          if (dm.actual) dm.actual = findColumn(dm.actual) || dm.actual
          if (dm.parent) dm.parent = findColumn(dm.parent) || dm.parent
          if (dm.source) dm.source = findColumn(dm.source) || dm.source
          if (dm.flow) dm.flow = findColumn(dm.flow) || dm.flow
          if (dm.type) dm.type = findColumn(dm.type) || dm.type
          if (dm.isTotal) dm.isTotal = findColumn(dm.isTotal) || dm.isTotal

          // Normalize target (can be string or number)
          if (dm.target && typeof dm.target === 'string') {
            dm.target = findColumn(dm.target) || dm.target
          }

          // Normalize arrays
          if (dm.values && Array.isArray(dm.values)) {
            dm.values = dm.values.map((col: string) => findColumn(col) || col)
          }
          if (dm.yAxis) {
            if (Array.isArray(dm.yAxis)) {
              dm.yAxis = dm.yAxis.map((col: string) => findColumn(col) || col)
            } else {
              dm.yAxis = findColumn(dm.yAxis) || dm.yAxis
            }
          }
          if (dm.yAxis2 && Array.isArray(dm.yAxis2)) {
            dm.yAxis2 = dm.yAxis2.map((col: string) => findColumn(col) || col)
          }
          if (dm.columns && Array.isArray(dm.columns)) {
            dm.columns = dm.columns.map((col: string) => findColumn(col) || col)
          }
          if (dm.size) dm.size = findColumn(dm.size) || dm.size
          if (dm.color) dm.color = findColumn(dm.color) || dm.color
        }
      })

      aiAnalysis.chartConfig = aiAnalysis.chartConfig.filter((config: any) => {
        const warnings: string[] = []
        const errors: string[] = []

        // If no dataMapping, try to migrate from legacy format
        if (!config.dataMapping) {
          logger.debug(`[VALIDATION] Chart "${config.title}" missing dataMapping, attempting migration...`)

          // Try to migrate from xAxis/yAxis or dataKey
          if (config.xAxis || config.yAxis || config.dataKey) {
            config.dataMapping = migrateLegacyFormat(config)
            warnings.push('Migrated from legacy format')
          } else {
            errors.push('No dataMapping and cannot migrate from legacy format')
          }
        }

        // Validate dataMapping based on chart type
        if (config.dataMapping) {
          const dm = config.dataMapping
          const invalidCols: string[] = []

          switch (config.type) {
            case 'bar':
              // Bar charts require: category + values array
              if (!dm.category) {
                errors.push('Bar chart missing required "category" field in dataMapping')
              } else if (!availableColumnsSet.has(dm.category)) {
                invalidCols.push(dm.category)
              }

              if (!dm.values || !Array.isArray(dm.values) || dm.values.length === 0) {
                errors.push('Bar chart missing required "values" array in dataMapping')
              } else {
                const invalidValues = dm.values.filter((col: string) => !availableColumnsSet.has(col))
                invalidCols.push(...invalidValues)
              }

              // Validate Top/Bottom X parameters
              if (dm.sortBy && !availableColumnsSet.has(dm.sortBy)) {
                errors.push(`sortBy column "${dm.sortBy}" not found in data`)
              }
              if (dm.sortOrder && !['asc', 'desc'].includes(dm.sortOrder)) {
                errors.push(`Invalid sortOrder: ${dm.sortOrder}. Must be "asc" or "desc"`)
              }
              if (dm.limit && (dm.limit < 1 || dm.limit > 100)) {
                errors.push(`Invalid limit: ${dm.limit}. Must be between 1 and 100`)
              }
              break

            case 'line':
            case 'area':
              // Line/Area charts require: xAxis + yAxis
              if (!dm.xAxis) {
                errors.push(`${config.type} chart missing required "xAxis" field in dataMapping`)
              } else if (!availableColumnsSet.has(dm.xAxis)) {
                invalidCols.push(dm.xAxis)
              }

              if (!dm.yAxis) {
                errors.push(`${config.type} chart missing required "yAxis" field in dataMapping`)
              } else {
                const yAxisCols = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
                const invalidY = yAxisCols.filter((col: string) => !availableColumnsSet.has(col))
                invalidCols.push(...invalidY)
              }
              break

            case 'pie':
              // Pie charts require: category + value (singular)
              if (!dm.category) {
                errors.push('Pie chart missing required "category" field in dataMapping')
              } else if (!availableColumnsSet.has(dm.category)) {
                invalidCols.push(dm.category)
              }

              if (!dm.value) {
                errors.push('Pie chart missing required "value" field in dataMapping')
              } else if (!availableColumnsSet.has(dm.value)) {
                invalidCols.push(dm.value)
              }
              break

            case 'scorecard':
              // Scorecards can use EITHER metric OR formula
              const isFormulaScorecard = !!dm.formula
              const isMetricScorecard = !!dm.metric

              if (!isFormulaScorecard && !isMetricScorecard) {
                errors.push('Scorecard missing required "metric" or "formula" field in dataMapping')
              }

              // For metric-based scorecards, validate metric column exists
              if (isMetricScorecard && !availableColumnsSet.has(dm.metric)) {
                invalidCols.push(dm.metric)
              }

              // Aggregation only required for metric-based scorecards
              if (isMetricScorecard && !dm.aggregation) {
                errors.push('Metric-based scorecard missing required "aggregation" field')
              } else if (isMetricScorecard && dm.aggregation && !['sum', 'avg', 'count', 'min', 'max', 'distinct'].includes(dm.aggregation)) {
                errors.push(`Invalid aggregation type: ${dm.aggregation}. Must be one of: sum, avg, count, min, max, distinct`)
              }

              // For formula-based scorecards, validate formula syntax (basic check)
              if (isFormulaScorecard && !dm.formulaAlias) {
                errors.push('Formula-based scorecard missing required "formulaAlias" field')
              }

              // Comparison is optional but validate if present
              if (dm.comparison && !availableColumnsSet.has(dm.comparison)) {
                warnings.push(`Comparison column "${dm.comparison}" not found in dataset`)
              }
              break

            case 'scatter':
              // Scatter requires: xAxis + yAxis
              if (!dm.xAxis) {
                errors.push('Scatter chart missing required "xAxis" field in dataMapping')
              } else if (!availableColumnsSet.has(dm.xAxis)) {
                invalidCols.push(dm.xAxis)
              }

              if (!dm.yAxis) {
                errors.push('Scatter chart missing required "yAxis" field in dataMapping')
              } else if (!availableColumnsSet.has(dm.yAxis as string)) {
                invalidCols.push(dm.yAxis as string)
              }

              // Size and color are optional but validate if present
              if (dm.size && !availableColumnsSet.has(dm.size)) {
                warnings.push(`Size column "${dm.size}" not found in dataset`)
              }
              if (dm.color && !availableColumnsSet.has(dm.color)) {
                warnings.push(`Color column "${dm.color}" not found in dataset`)
              }
              break

            case 'table':
              // Tables require: columns array
              if (!dm.columns || !Array.isArray(dm.columns) || dm.columns.length === 0) {
                errors.push('Table missing required "columns" array in dataMapping')
              } else {
                const invalidCols = dm.columns.filter((col: string) => !availableColumnsSet.has(col))
                if (invalidCols.length > 0) {
                  warnings.push(`Some columns not found: ${invalidCols.join(', ')}`)
                }
              }
              break

            case 'combo':
              if (!dm.xAxis) errors.push('Combo chart missing required "xAxis" field')
              if (!dm.yAxis || dm.yAxis.length === 0) {
                errors.push('Combo chart missing required "yAxis" field')
              }
              if (!dm.yAxis2 || dm.yAxis2.length === 0) {
                errors.push('Combo chart missing required "yAxis2" field')
              }
              if (!dm.yAxis1Type) errors.push('Combo chart missing "yAxis1Type"')
              if (!dm.yAxis2Type) errors.push('Combo chart missing "yAxis2Type"')

              // Validate columns exist
              if (dm.xAxis && !availableColumnsSet.has(dm.xAxis)) {
                invalidCols.push(dm.xAxis)
              }
              const yAxis1Cols = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
              const yAxis2Cols = Array.isArray(dm.yAxis2) ? dm.yAxis2 : [dm.yAxis2]
              invalidCols.push(...yAxis1Cols.filter((col: string) => !availableColumnsSet.has(col)))
              invalidCols.push(...yAxis2Cols.filter((col: string) => !availableColumnsSet.has(col)))
              break

            case 'waterfall':
              // Waterfall requires: category + value
              if (!dm.category) {
                errors.push('Waterfall chart missing required "category" field')
              } else if (!availableColumnsSet.has(dm.category)) {
                invalidCols.push(dm.category)
              }
              if (!dm.value) {
                errors.push('Waterfall chart missing required "value" field')
              } else if (!availableColumnsSet.has(dm.value)) {
                invalidCols.push(dm.value)
              }
              // type and isTotal are optional
              if (dm.type && !availableColumnsSet.has(dm.type)) {
                warnings.push(`Type column "${dm.type}" not found`)
              }
              if (dm.isTotal && !availableColumnsSet.has(dm.isTotal)) {
                warnings.push(`IsTotal column "${dm.isTotal}" not found`)
              }
              break

            case 'funnel':
              // Funnel requires: stage + value
              if (!dm.stage) {
                errors.push('Funnel chart missing required "stage" field')
              } else if (!availableColumnsSet.has(dm.stage)) {
                invalidCols.push(dm.stage)
              }
              if (!dm.value) {
                errors.push('Funnel chart missing required "value" field')
              } else if (!availableColumnsSet.has(dm.value)) {
                invalidCols.push(dm.value)
              }
              break

            case 'heatmap':
              // Heatmap requires: xAxis + yAxis + value
              if (!dm.xAxis) {
                errors.push('Heatmap missing required "xAxis" field')
              } else if (!availableColumnsSet.has(dm.xAxis)) {
                invalidCols.push(dm.xAxis)
              }
              if (!dm.yAxis) {
                errors.push('Heatmap missing required "yAxis" field')
              } else {
                const yCol = Array.isArray(dm.yAxis) ? dm.yAxis[0] : dm.yAxis
                if (!availableColumnsSet.has(yCol)) {
                  invalidCols.push(yCol)
                }
              }
              if (!dm.value) {
                errors.push('Heatmap missing required "value" field')
              } else if (!availableColumnsSet.has(dm.value)) {
                invalidCols.push(dm.value)
              }
              break

            case 'gauge':
              // Gauge requires: metric
              if (!dm.metric) {
                errors.push('Gauge chart missing required "metric" field')
              } else if (!availableColumnsSet.has(dm.metric)) {
                invalidCols.push(dm.metric)
              }
              // target is optional but validate if present
              if (dm.target && typeof dm.target === 'string' && !availableColumnsSet.has(dm.target)) {
                warnings.push(`Target column "${dm.target}" not found`)
              }
              break

            case 'cohort':
              // Cohort requires: cohort + period + retention
              if (!dm.cohort) {
                errors.push('Cohort chart missing required "cohort" field')
              } else if (!availableColumnsSet.has(dm.cohort)) {
                invalidCols.push(dm.cohort)
              }
              if (!dm.period) {
                errors.push('Cohort chart missing required "period" field')
              } else if (!availableColumnsSet.has(dm.period)) {
                invalidCols.push(dm.period)
              }
              if (!dm.retention) {
                errors.push('Cohort chart missing required "retention" field')
              } else if (!availableColumnsSet.has(dm.retention)) {
                invalidCols.push(dm.retention)
              }
              break

            case 'bullet':
              // Bullet requires: metric (actual)
              if (!dm.metric && !dm.actual) {
                errors.push('Bullet chart missing required "metric" or "actual" field')
              } else {
                const actualCol = dm.actual || dm.metric
                if (actualCol && !availableColumnsSet.has(actualCol)) {
                  invalidCols.push(actualCol)
                }
              }
              // target is optional but validate if present
              if (dm.target && typeof dm.target === 'string' && !availableColumnsSet.has(dm.target)) {
                warnings.push(`Target column "${dm.target}" not found`)
              }
              break

            case 'treemap':
              // Treemap requires: category + value
              if (!dm.category) {
                errors.push('Treemap missing required "category" field')
              } else if (!availableColumnsSet.has(dm.category)) {
                invalidCols.push(dm.category)
              }
              if (!dm.value) {
                errors.push('Treemap missing required "value" field')
              } else if (!availableColumnsSet.has(dm.value)) {
                invalidCols.push(dm.value)
              }
              // parent is optional for hierarchy
              if (dm.parent && !availableColumnsSet.has(dm.parent)) {
                warnings.push(`Parent column "${dm.parent}" not found`)
              }
              break

            case 'sankey':
              // Sankey requires: source + target + flow
              if (!dm.source) {
                errors.push('Sankey chart missing required "source" field')
              } else if (!availableColumnsSet.has(dm.source)) {
                invalidCols.push(dm.source)
              }
              if (!dm.target) {
                errors.push('Sankey chart missing required "target" field')
              } else if (typeof dm.target === 'string' && !availableColumnsSet.has(dm.target)) {
                invalidCols.push(dm.target)
              }
              if (!dm.flow) {
                errors.push('Sankey chart missing required "flow" field')
              } else if (!availableColumnsSet.has(dm.flow)) {
                invalidCols.push(dm.flow)
              }
              break

            case 'sparkline':
              // Sparkline requires: xAxis + yAxis (like line chart)
              if (!dm.xAxis) {
                errors.push('Sparkline missing required "xAxis" field')
              } else if (!availableColumnsSet.has(dm.xAxis)) {
                invalidCols.push(dm.xAxis)
              }
              if (!dm.yAxis) {
                errors.push('Sparkline missing required "yAxis" field')
              } else {
                const yAxisCols = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
                const invalidY = yAxisCols.filter((col: string) => !availableColumnsSet.has(col))
                invalidCols.push(...invalidY)
              }
              break

            default:
              warnings.push(`Unknown chart type: ${config.type}`)
          }

          // Report invalid columns
          if (invalidCols.length > 0) {
            errors.push(`Invalid column names: ${invalidCols.join(', ')}`)
          }
        }

        // Log errors and warnings
        if (errors.length > 0) {
          logger.error(`[VALIDATION] Chart "${config.title}" has errors:`, errors.join('; '))
          dataMappingValidationErrors++
          return false // Filter out charts with errors
        }

        if (warnings.length > 0) {
          logger.warn(`[VALIDATION] Chart "${config.title}" has warnings:`, warnings.join('; '))
          dataMappingValidationWarnings++
        }

        return true // Keep valid charts
      })

      logger.debug('[VALIDATION] Data mapping validation completed:', {
        totalCharts: aiAnalysis.chartConfig.length,
        errors: dataMappingValidationErrors,
        warnings: dataMappingValidationWarnings
      })

      // Chart diversity validation
      const scorecardCount = aiAnalysis.chartConfig.filter((c: any) => c.type === 'scorecard').length
      const topBottomCount = aiAnalysis.chartConfig.filter((c: any) =>
        c.type === 'bar' && c.dataMapping?.sortBy && c.dataMapping?.limit
      ).length

      logger.debug('[VALIDATION] Chart diversity:', {
        scorecards: scorecardCount,
        topBottom: topBottomCount,
        total: aiAnalysis.chartConfig.length
      })

      if (scorecardCount === 0) {
        logger.warn('[VALIDATION] No scorecards generated')
      }
      if (topBottomCount === 0) {
        logger.warn('[VALIDATION] No Top/Bottom X charts generated')
      }

      // Ensure we still have enough recommendations after filtering
      if (aiAnalysis.chartConfig.length < 4) {
        logger.warn('[VALIDATION] Too few charts after filtering:', aiAnalysis.chartConfig.length)
        // Note: We continue with what we have rather than failing
      }

      // Check for expected chart count
      if (aiAnalysis.chartConfig.length < 16) {
        logger.warn('[VALIDATION] Chart count below minimum:', {
          count: aiAnalysis.chartConfig.length,
          minimum: 16
        })
      }

      if (scorecardCount !== 6) {
        logger.warn('[VALIDATION] Incorrect scorecard count:', {
          actual: scorecardCount,
          expected: 6
        })
      }

      // Scoring integration - Score and rank all recommendations
      logger.debug('[API-ANALYZE] Starting recommendation scoring...')

      // Build data profile for scoring
      const dataProfile: DataProfile = {
        schema: schema || {
          fileName: fileName || 'data.csv',
          rowCount: dataStructure.rowCount,
          columnCount: dataStructure.columnCount,
          columns: dataStructure.columns.map((col: any) => ({
            name: col.name,
            type: col.type as any,
            confidence: 85,
            detectionReason: 'Pattern match',
            suggestedUsage: [],
            uniqueValues: col.uniqueValues,
            sampleValues: col.sampleValues || [],
            nullCount: col.nullCount,
            nullPercentage: col.nullPercentage
          })),
          businessContext: 'General data analysis',
          uploadedAt: new Date().toISOString()
        },
        sampleData: data,
        totalRows: dataStructure.rowCount
      }

      // Convert correctedSchema to scorer format
      const scorerCorrectedColumns: ScorerCorrectedColumn[] | undefined = correctedSchema?.map(col => {
        const originalCol = dataStructure.columns.find((c: any) => c.name === col.name)
        return {
          name: col.name,
          originalType: originalCol?.type || 'string',
          correctedType: col.type,
          confidence: 100
        }
      })

      // Convert AI chart configs to ChartSuggestion format and score them
      let scoredRecommendations: ScoredRecommendation[] = []
      try {
        const chartSuggestions = aiAnalysis.chartConfig.map((config: any, index: number) =>
          convertToChartSuggestion(config, index)
        )

        // Score and rank recommendations
        scoredRecommendations = rankRecommendations(
          chartSuggestions,
          dataProfile,
          scorerCorrectedColumns
        )

        // Calculate quality statistics
        const avgQualityScore = scoredRecommendations.length > 0
          ? scoredRecommendations.reduce((sum, r) => sum + r.qualityScore, 0) / scoredRecommendations.length
          : 0

        const highQualityCount = scoredRecommendations.filter(r => r.qualityScore > 75).length
        const mediumQualityCount = scoredRecommendations.filter(r => r.qualityScore >= 60 && r.qualityScore <= 75).length
        const lowQualityCount = scoredRecommendations.filter(r => r.qualityScore < 60).length

        const recommendationsWithCorrections = scoredRecommendations.filter(r =>
          r.qualityFactors.userCorrectionBoost > 0
        ).length

        logger.info('[API-ANALYZE] Recommendation scoring completed:', {
          total: scoredRecommendations.length,
          avgScore: Math.round(avgQualityScore),
          highQuality: highQualityCount
        })

      } catch (scoringError) {
        logger.error('[API-ANALYZE] Scoring failed, continuing without scores:', {
          error: scoringError instanceof Error ? scoringError.message : 'Unknown error'
        })
        // Continue with unscored recommendations
      }

      // Build enhanced analysis result with confidence scores and user corrections
      const correctedColumnNames = correctedSchema?.map(c => c.name) || []

      const analysisResult: AnalysisResult & {
        schema?: any
        recommendations?: ChartRecommendation[]
        dataContext?: DataContext
        qualityMetrics?: {
          averageQualityScore: number
          highQualityCount: number
          mediumQualityCount: number
          lowQualityCount: number
          withUserCorrections: number
        }
      } = {
        insights: aiAnalysis.insights,

        // Map chart configs to include confidence, reasoning, quality scores, and dataMapping
        chartConfig: aiAnalysis.chartConfig.map((config: any, index: number) => {
          const scoredRec = scoredRecommendations.find(sr => sr.id === `chart-${index}-${config.type}`)

          // Build backward-compatible dataKey from dataMapping
          let legacyDataKey: string[] = []
          if (config.dataMapping) {
            const dm = config.dataMapping
            switch (config.type) {
              case 'bar':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.values) legacyDataKey.push(...dm.values)
                break
              case 'line':
              case 'area':
                if (dm.xAxis) legacyDataKey.push(dm.xAxis)
                if (dm.yAxis) {
                  const yValues = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
                  legacyDataKey.push(...yValues)
                }
                break
              case 'pie':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.value) legacyDataKey.push(dm.value)
                break
              case 'scorecard':
                if (dm.metric) legacyDataKey.push(dm.metric)
                break
              case 'scatter':
                if (dm.xAxis) legacyDataKey.push(dm.xAxis)
                if (dm.yAxis) legacyDataKey.push(dm.yAxis as string)
                break
              case 'table':
                if (dm.columns) legacyDataKey.push(...dm.columns)
                break
              case 'combo':
                if (dm.xAxis) legacyDataKey.push(dm.xAxis)
                if (dm.yAxis) {
                  const yValues = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
                  legacyDataKey.push(...yValues)
                }
                if (dm.yAxis2) {
                  const y2Values = Array.isArray(dm.yAxis2) ? dm.yAxis2 : [dm.yAxis2]
                  legacyDataKey.push(...y2Values)
                }
                break
              case 'waterfall':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.value) legacyDataKey.push(dm.value)
                if (dm.type && typeof dm.type === 'string') legacyDataKey.push(dm.type)
                break
              case 'funnel':
                if (dm.stage) legacyDataKey.push(dm.stage)
                if (dm.value) legacyDataKey.push(dm.value)
                break
              case 'heatmap':
                if (dm.xAxis && typeof dm.xAxis === 'string') legacyDataKey.push(dm.xAxis)
                if (dm.yAxis && typeof dm.yAxis === 'string') legacyDataKey.push(dm.yAxis)
                if (dm.value) legacyDataKey.push(dm.value)
                break
              case 'gauge':
                if (dm.metric) legacyDataKey.push(dm.metric)
                if (dm.target && typeof dm.target === 'string') legacyDataKey.push(dm.target)
                break
              case 'cohort':
                if (dm.cohort) legacyDataKey.push(dm.cohort)
                if (dm.period) legacyDataKey.push(dm.period)
                if (dm.retention) legacyDataKey.push(dm.retention)
                break
              case 'bullet':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.actual) legacyDataKey.push(dm.actual)
                if (dm.target && typeof dm.target === 'string') legacyDataKey.push(dm.target)
                break
              case 'treemap':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.value) legacyDataKey.push(dm.value)
                if (dm.parent && typeof dm.parent === 'string') legacyDataKey.push(dm.parent)
                break
              case 'sankey':
                if (dm.source) legacyDataKey.push(dm.source)
                if (dm.target && typeof dm.target === 'string') legacyDataKey.push(dm.target)
                if (dm.flow || dm.value) legacyDataKey.push(dm.flow || dm.value)
                break
              case 'sparkline':
                if (dm.xAxis && typeof dm.xAxis === 'string') legacyDataKey.push(dm.xAxis)
                if (dm.yAxis && typeof dm.yAxis === 'string') legacyDataKey.push(dm.yAxis)
                if (dm.trend) legacyDataKey.push(dm.trend)
                break
            }
          }

          return {
            type: config.type,
            title: config.title,
            description: config.description,
            // Primary: chart-type-specific dataMapping
            dataMapping: config.dataMapping,
            // Legacy fields for backward compatibility
            dataKey: legacyDataKey.length > 0 ? legacyDataKey : undefined,
            xAxis: config.xAxis,
            yAxis: config.yAxis,
            aggregation: config.aggregation || config.dataMapping?.aggregation,
            confidence: config.confidence || 85,
            reasoning: config.reasoning,
            // Add quality scoring data
            qualityScore: scoredRec?.qualityScore,
            qualityFactors: scoredRec?.qualityFactors
          }
        }).sort((a: any, b: any) => {
          // Sort by quality score if available, otherwise by original confidence
          const scoreA = a.qualityScore ?? a.confidence
          const scoreB = b.qualityScore ?? b.confidence
          return scoreB - scoreA
        }),

        // Store enhanced recommendations separately for future use
        recommendations: aiAnalysis.chartConfig.map((config: any) => {
          // Build backward-compatible dataKey from dataMapping
          let legacyDataKey: string[] = []
          if (config.dataMapping) {
            const dm = config.dataMapping
            switch (config.type) {
              case 'bar':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.values) legacyDataKey.push(...dm.values)
                break
              case 'line':
              case 'area':
                if (dm.xAxis) legacyDataKey.push(dm.xAxis)
                if (dm.yAxis) {
                  const yValues = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
                  legacyDataKey.push(...yValues)
                }
                break
              case 'pie':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.value) legacyDataKey.push(dm.value)
                break
              case 'scorecard':
                if (dm.metric) legacyDataKey.push(dm.metric)
                break
              case 'scatter':
                if (dm.xAxis) legacyDataKey.push(dm.xAxis)
                if (dm.yAxis) legacyDataKey.push(dm.yAxis as string)
                break
              case 'table':
                if (dm.columns) legacyDataKey.push(...dm.columns)
                break
              case 'combo':
                if (dm.xAxis) legacyDataKey.push(dm.xAxis)
                if (dm.yAxis) {
                  const yValues = Array.isArray(dm.yAxis) ? dm.yAxis : [dm.yAxis]
                  legacyDataKey.push(...yValues)
                }
                if (dm.yAxis2) {
                  const y2Values = Array.isArray(dm.yAxis2) ? dm.yAxis2 : [dm.yAxis2]
                  legacyDataKey.push(...y2Values)
                }
                break
              case 'waterfall':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.value) legacyDataKey.push(dm.value)
                if (dm.type && typeof dm.type === 'string') legacyDataKey.push(dm.type)
                break
              case 'funnel':
                if (dm.stage) legacyDataKey.push(dm.stage)
                if (dm.value) legacyDataKey.push(dm.value)
                break
              case 'heatmap':
                if (dm.xAxis && typeof dm.xAxis === 'string') legacyDataKey.push(dm.xAxis)
                if (dm.yAxis && typeof dm.yAxis === 'string') legacyDataKey.push(dm.yAxis)
                if (dm.value) legacyDataKey.push(dm.value)
                break
              case 'gauge':
                if (dm.metric) legacyDataKey.push(dm.metric)
                if (dm.target && typeof dm.target === 'string') legacyDataKey.push(dm.target)
                break
              case 'cohort':
                if (dm.cohort) legacyDataKey.push(dm.cohort)
                if (dm.period) legacyDataKey.push(dm.period)
                if (dm.retention) legacyDataKey.push(dm.retention)
                break
              case 'bullet':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.actual) legacyDataKey.push(dm.actual)
                if (dm.target && typeof dm.target === 'string') legacyDataKey.push(dm.target)
                break
              case 'treemap':
                if (dm.category) legacyDataKey.push(dm.category)
                if (dm.value) legacyDataKey.push(dm.value)
                if (dm.parent && typeof dm.parent === 'string') legacyDataKey.push(dm.parent)
                break
              case 'sankey':
                if (dm.source) legacyDataKey.push(dm.source)
                if (dm.target && typeof dm.target === 'string') legacyDataKey.push(dm.target)
                if (dm.flow || dm.value) legacyDataKey.push(dm.flow || dm.value)
                break
              case 'sparkline':
                if (dm.xAxis && typeof dm.xAxis === 'string') legacyDataKey.push(dm.xAxis)
                if (dm.yAxis && typeof dm.yAxis === 'string') legacyDataKey.push(dm.yAxis)
                if (dm.trend) legacyDataKey.push(dm.trend)
                break
            }
          }

          return {
            type: config.type,
            title: config.title,
            description: config.description,
            dataMapping: config.dataMapping,
            dataKey: legacyDataKey.length > 0 ? legacyDataKey : undefined,
            xAxis: config.xAxis,
            yAxis: config.yAxis,
            aggregation: config.aggregation || config.dataMapping?.aggregation,
            confidence: config.confidence || 85,
            reasoning: config.reasoning
          }
        }),

        summary: {
          rowCount: dataStructure.rowCount,
          columnCount: dataStructure.columnCount,
          columns: dataStructure.columns.map((col: any) => ({
            name: col.name,
            type: col.type,
            uniqueValues: col.uniqueValues,
            nullCount: col.nullCount
          })),
          // Add AI-generated summary fields
          ...(aiAnalysis.summary && {
            dataQuality: aiAnalysis.summary.dataQuality,
            keyFindings: aiAnalysis.summary.keyFindings,
            recommendations: aiAnalysis.summary.recommendations,
            businessContext: aiAnalysis.summary.businessContext || aiAnalysis.dataContext
          }),
          // Add user correction metadata
          ...(correctedColumnNames.length > 0 && {
            correctedColumns: correctedColumnNames,
            improvementNotes: feedback || `User corrected ${correctedColumnNames.length} column(s) for improved recommendations`
          })
        },

        // Add quality metrics to response
        qualityMetrics: scoredRecommendations.length > 0 ? {
          averageQualityScore: Math.round(
            scoredRecommendations.reduce((sum, r) => sum + r.qualityScore, 0) / scoredRecommendations.length
          ),
          highQualityCount: scoredRecommendations.filter(r => r.qualityScore > 75).length,
          mediumQualityCount: scoredRecommendations.filter(r => r.qualityScore >= 60 && r.qualityScore <= 75).length,
          lowQualityCount: scoredRecommendations.filter(r => r.qualityScore < 60).length,
          withUserCorrections: scoredRecommendations.filter(r => r.qualityFactors.userCorrectionBoost > 0).length
        } : undefined
      }

      // REBALANCE CHARTS: Enforce exactly 16 charts with layout constraints
      logger.info('[API-ANALYZE] Rebalancing charts before response:', {
        beforeCount: analysisResult.chartConfig.length,
        scorecards: analysisResult.chartConfig.filter((c: any) => c.type === 'scorecard').length,
        tables: analysisResult.chartConfig.filter((c: any) => c.type === 'table').length
      })

      // Apply rebalancing to chartConfig
      // IMPORTANT: For e-commerce/FBA/financial dashboards, we need many KPI scorecards
      // AI is prompted to generate 8+ diverse scorecards (sum, avg, count, min, max, distinct)
      // Allow up to 10 scorecards to show rich KPI metrics, leaving 5 slots for analytical charts + 1 table
      analysisResult.chartConfig = rebalanceCharts(analysisResult.chartConfig as any, 16, {
        minScorecards: 0,   // Don't force minimum - use what AI generated
        maxScorecards: 10,  // Allow up to 10 scorecards for rich KPI dashboards
        preferredScorecards: 8,  // Prefer 8 scorecards (matches AI prompt)
        requireTable: true
      }) as any

      // Log rebalancing results
      const chartStats = getChartStats(analysisResult.chartConfig as any)
      logger.info('[API-ANALYZE] Charts rebalanced successfully:', chartStats)

      // Validate layout
      const validation = validateChartLayout(analysisResult.chartConfig as any)
      if (!validation.valid) {
        logger.warn('[API-ANALYZE] Chart layout validation warnings:', validation.errors)
      }

      // Build enhanced data context
      const dataContext: DataContext = {
        rowCount: dataStructure.rowCount,
        columnCount: dataStructure.columnCount,
        columns: dataStructure.columns as ColumnSchema[],
        ...(correctedColumnNames.length > 0 && {
          correctedColumns: correctedColumnNames,
          improvementNotes: feedback || `Analysis improved with ${correctedColumnNames.length} user correction(s)`
        })
      }
      analysisResult.dataContext = dataContext

      // If corrected schema was provided, include enhanced schema info
      if (correctedSchema && correctedSchema.length > 0) {
        const { analyzeDataSchema } = await import('@/lib/utils/schema-analyzer')
        const enhancedSchema = analyzeDataSchema(data, fileName || 'data.csv')

        // Merge user corrections with enhanced detection
        analysisResult.schema = {
          ...enhancedSchema,
          columns: enhancedSchema.columns.map(col => {
            const userCorrection = correctedSchema.find(c => c.name === col.name)
            if (userCorrection) {
              return {
                ...col,
                type: userCorrection.type as any,
                description: userCorrection.description || col.description,
                userCorrected: true,
                confidence: 100 // User corrected, so 100% confidence
              }
            }
            return col
          }),
          businessContext: aiAnalysis.summary?.businessContext,
          relationships: enhancedSchema.relationships
        }
      }
      
      // Log enhanced analysis completion
      const totalDuration = Date.now() - requestStartTime
      logger.info('[API-ANALYZE] Analysis completed:', {
        totalVisualizations: aiAnalysis.chartConfig?.length || 0,
        scorecards: aiAnalysis.chartConfig?.filter((c: any) => c.type === 'scorecard').length || 0,
        userCorrections: correctedColumnNames.length,
        duration: totalDuration + 'ms'
      })

      logger.debug('[API-ANALYZE] Response structure:', {
        chartCount: analysisResult.chartConfig.length,
        chartTypes: analysisResult.chartConfig.map((c: any) => c.type)
      })

        return NextResponse.json(analysisResult)

      } catch (parseError) {
        logger.error('[API-ANALYZE] Error parsing OpenAI response:', {
          error: parseError instanceof Error ? parseError.message : 'Unknown error',
          responseLength: response?.length
        })
        logger.debug('[API-ANALYZE] Response preview:', response?.substring(0, 200))

        // Return error if AI response is malformed
        return NextResponse.json(
          {
            error: 'Failed to parse AI response. Please try again.',
            details: parseError instanceof Error ? parseError.message : 'Unknown error'
          },
          { status: 500 }
        )
      }

  } catch (error) {
    const totalDuration = Date.now() - requestStartTime
    logger.error('[API-ANALYZE] Error in analysis API:', {
      error: error instanceof Error ? error.message : 'Unknown error',
      duration: totalDuration + 'ms'
    })

    // Detailed error logging for OpenAI issues
    if (error && typeof error === 'object') {
      const err = error as any
      logger.debug('Error details:', {
        code: err.code,
        type: err.type,
        status: err.status
      })

      // Check for specific OpenAI error types
      if (err.code === 'rate_limit_exceeded') {
        logger.error('[API-ANALYZE] Rate limit exceeded:', err.message)
        return NextResponse.json(
          { 
            error: 'Rate limit exceeded. Please wait a moment and try again.',
            type: 'rate_limit',
            details: err.message
          },
          { status: 429 }
        )
      }
      
      if (err.code === 'insufficient_quota') {
        logger.error('[API-ANALYZE] Insufficient quota:', err.message)
        return NextResponse.json(
          {
            error: 'OpenAI quota exceeded. Please check your billing.',
            type: 'quota_exceeded',
            details: err.message
          },
          { status: 402 }
        )
      }

      if (err.status === 429) {
        logger.error('[API-ANALYZE] 429 Rate limit from OpenAI:', err.message)
        return NextResponse.json(
          { 
            error: 'Too many requests to OpenAI. Please try again in a few minutes.',
            type: 'rate_limit',
            details: err.message
          },
          { status: 429 }
        )
      }
      
      if (err.status === 401) {
        logger.error('[API-ANALYZE] 401 Unauthorized from OpenAI:', err.message)
        return NextResponse.json(
          {
            error: 'OpenAI API key is invalid or expired.',
            type: 'auth_error',
            details: err.message
          },
          { status: 401 }
        )
      }

      if (err.status >= 500) {
        logger.error('[API-ANALYZE] OpenAI server error:', err.status, err.message)
        return NextResponse.json(
          { 
            error: 'OpenAI service is temporarily unavailable.',
            type: 'server_error',
            details: err.message
          },
          { status: 503 }
        )
      }
    }
    
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Analysis failed',
        type: 'unknown_error',
        details: 'Please check your data format and try again'
      },
      { status: 500 }
    )
  }
}


// Fallback function removed - OpenAI API key is now required
