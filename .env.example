# DataCrafted Environment Configuration
# Copy this file to .env.local and fill in your values

# OpenAI API Configuration (Optional)
# Used for enhanced data analysis and AI-powered column descriptions
# If not provided, the app will use fallback analysis
OPENAI_API_KEY=

# Firebase Configuration (Optional)
# Used for user authentication
# If not provided, the app will work with anonymous users
NEXT_PUBLIC_FIREBASE_API_KEY=
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=
NEXT_PUBLIC_FIREBASE_PROJECT_ID=
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=
NEXT_PUBLIC_FIREBASE_APP_ID=
NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=

# Firebase Admin SDK (Server-side only)
# Required for API route authentication and token verification
# Method 1: Use entire service account JSON (recommended for development)
# Download from Firebase Console > Project Settings > Service Accounts
# FIREBASE_SERVICE_ACCOUNT_KEY={"type":"service_account","project_id":"...","private_key":"..."}

# Method 2: Use individual credentials (alternative)
# FIREBASE_CLIENT_EMAIL=your-service-account@your-project.iam.gserviceaccount.com
# FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
# The application uses PostgreSQL with Prisma ORM
#
# Connection URL Format:
# postgresql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=10&pool_timeout=20
#
# IMPORTANT CONNECTION POOLING PARAMETERS:
#
# connection_limit (default: 10)
# - Maximum number of database connections in the pool
# - Each Prisma Client instance maintains its own connection pool
# - Recommended values:
#   * Development: 5-10
#   * Production (single instance): 10-20
#   * Production (multiple instances): Calculate per instance
#     Example: If DB allows 100 connections and you have 5 app instances:
#     100 / 5 = 20 connections per instance (leave some buffer for admin tools)
# - Too high: May exhaust database connection limits
# - Too low: May cause connection pool timeout errors under load
#
# pool_timeout (default: 10 seconds)
# - Maximum time (in seconds) to wait for an available connection
# - If all connections are busy, new requests wait up to this duration
# - Recommended: 10-20 seconds for most applications
# - Too high: Requests may hang for too long
# - Too low: May fail under temporary load spikes
#
# Example URLs:
#
# Local PostgreSQL:
# DATABASE_URL="postgresql://postgres:password@localhost:5432/datacrafted?connection_limit=10&pool_timeout=20"
#
# Supabase (requires both pooler and direct connection):
# Transaction pooler (port 6543) - used for queries at runtime
# DATABASE_URL="postgresql://postgres.xxxxxxxxxxxx:password@aws-0-us-west-1.pooler.supabase.com:6543/postgres?pgbouncer=true&connection_limit=10&pool_timeout=20"
#
# Direct connection (port 5432) - required for migrations and schema operations
# DIRECT_DATABASE_URL="postgresql://postgres.xxxxxxxxxxxx:password@aws-0-us-west-1.pooler.supabase.com:5432/postgres?connection_limit=1"
#
# NOTE: Both URLs use the same host/credentials, only the port differs
# - Port 6543: Transaction pooler (PgBouncer) for application queries
# - Port 5432: Direct connection for Prisma migrations and introspection
#
# Railway:
# DATABASE_URL="postgresql://postgres:password@containers-us-west-xxx.railway.app:5432/railway?connection_limit=15&pool_timeout=20"
#
# Neon (serverless Postgres - use higher limits):
# DATABASE_URL="postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?connection_limit=20&pool_timeout=20&sslmode=require"
#
# Render:
# DATABASE_URL="postgresql://user:password@dpg-xxxxxxxxxxxx.oregon-postgres.render.com/dbname?connection_limit=10&pool_timeout=20"
#
# PRODUCTION RECOMMENDATIONS:
# 1. Always use connection pooling in production
# 2. Monitor your database connection usage
# 3. Set connection_limit based on:
#    - Your database plan's connection limit
#    - Number of application instances
#    - Expected concurrent request load
# 4. Enable SSL in production (add sslmode=require)
# 5. Use PgBouncer or similar for connection pooling at database level
# 6. Consider read replicas for read-heavy workloads
#
# DEVELOPMENT:
DATABASE_URL="postgresql://postgres:password@localhost:5432/datacrafted?connection_limit=5&pool_timeout=10"
#
# Note: The schema.prisma file is configured to use PostgreSQL
# =============================================================================

# Application Settings
NEXT_PUBLIC_APP_URL=http://localhost:3000
NODE_ENV=development

# =============================================================================
# CORS CONFIGURATION (Production Security)
# =============================================================================
# SECURITY: Configure allowed origins for Cross-Origin Resource Sharing (CORS)
#
# IMPORTANT: CORS prevents unauthorized domains from accessing your API
# - Development: Automatically allows localhost origins (http://localhost:3000, etc.)
# - Production: MUST configure ALLOWED_ORIGINS with your actual domains
#
# Format: Comma-separated list of allowed origin URLs
# Example: ALLOWED_ORIGINS=https://datacrafted.com,https://www.datacrafted.com,https://app.datacrafted.com
#
# SECURITY REQUIREMENTS:
# - Use HTTPS URLs in production (HTTP is automatically upgraded to HTTPS)
# - Include all subdomains that need API access (www, app, api, etc.)
# - Never use wildcards (*) - explicit domains only
# - Keep the list minimal (only trusted domains)
#
# TESTING:
# 1. After deployment, test from your frontend domain
# 2. Check browser console for CORS errors
# 3. Verify in Network tab: Response has "Access-Control-Allow-Origin" header
# 4. Test with curl: curl -H "Origin: https://yourdomain.com" https://api.yourdomain.com/api/health
#
# Production Example:
# ALLOWED_ORIGINS=https://datacrafted.com,https://www.datacrafted.com,https://app.datacrafted.com
#
# Development (automatic - no configuration needed):
# Localhost origins are automatically allowed in development mode
# =============================================================================
ALLOWED_ORIGINS=

# Feature Flags (Optional)
# Control which features are enabled
NEXT_PUBLIC_ENABLE_AI_ANALYSIS=true
NEXT_PUBLIC_ENABLE_EXPORT=true
NEXT_PUBLIC_MAX_FILE_SIZE_MB=50
NEXT_PUBLIC_MAX_ROWS=100000

# =============================================================================
# DEBUG MODE - LOCAL DEVELOPMENT ONLY (Server-Side Only)
# =============================================================================
# ⚠️  CRITICAL SECURITY WARNING ⚠️
#
# DEBUG_MODE completely bypasses ALL authentication and authorization checks.
# This creates a CRITICAL SECURITY VULNERABILITY if enabled in production.
#
# SECURITY IMPLEMENTATION:
# - Uses DEBUG_MODE (NOT NEXT_PUBLIC_) to prevent client bundle exposure
# - Server-side only - not accessible from client JavaScript
# - Production environment detection prevents debug mode activation
# - Fatal error is thrown if DEBUG_MODE is attempted in production
# - Multiple layers of defense-in-depth protection
#
# ONLY enable this in LOCAL DEVELOPMENT:
# - localhost development
# - No cloud hosting environment detected (Vercel, Railway, Render, Fly.io, etc.)
# - NODE_ENV must be 'development'
#
# When DEBUG_MODE is enabled:
# - Server-side: API routes accept any token and return debug user
# - Middleware bypasses authentication checks
# - Debug user: debug@datacrafted.com (uid: debug-user-123)
#
# DEPRECATED: NEXT_PUBLIC_DEBUG_MODE
# - Do NOT use NEXT_PUBLIC_DEBUG_MODE (exposes to client bundle)
# - Use DEBUG_MODE without NEXT_PUBLIC_ prefix instead
#
# NEVER SET TO TRUE IN PRODUCTION
# =============================================================================
DEBUG_MODE=false

# =============================================================================
# OPTIONAL: REDIS FOR DISTRIBUTED RATE LIMITING
# =============================================================================
# Recommended for production deployments with multiple instances
# Without Redis, rate limiting uses in-memory store (not suitable for multi-instance)
# Sign up for free at https://upstash.com
# UPSTASH_REDIS_REST_URL=https://your-redis-url.upstash.io
# UPSTASH_REDIS_REST_TOKEN=your-redis-token
#
# Benefits of using Redis:
# - Distributed rate limiting across all server instances
# - Rate limits persist across deployments and restarts
# - More accurate with sliding window algorithm
# - Better performance under high load
# - Automatic fallback to in-memory if Redis fails
# =============================================================================

# =============================================================================
# OPTIONAL: MONITORING & ERROR TRACKING
# =============================================================================
# Sentry for error tracking and monitoring
# Sign up at https://sentry.io
# SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
#
# Google Analytics for usage analytics
# NEXT_PUBLIC_GA_MEASUREMENT_ID=G-XXXXXXXXXX
# =============================================================================